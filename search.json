[{"title":"CSS基础","url":"/2023/05/03/CSS%E5%9F%BA%E7%A1%80/","content":"文字 fontfont-weight:bold;font-style:italic;font-variant:small-caps;font-size:lem;line-height:1.5em;font-family:verdana,sans-serif\n\n上述代码可以简写为\nfont:bold italic small-caps lem/1.5em verdana,sans-serif\n必须包括的属性值为font-size和font-family\n背景backgroundbackground-color:green;background-image:none;background-repeat:repeat;background-position:top;background-size:auto;background-clip:border-box;background-origin:border-box;\nbackground: color image repeat position\n边框线boder = border-color border-style  border-widthborder-radiusbox-shadowborder-image\n高度和宽度height width min-height min-width max-height max-width box-sizing\n内、外边距内边距 padding外边距 margin\n列表和表格list-style = list-style-type:Disc list-style-position:inside list-style-image:noneborder-collapses:collapseborder-spacing:10px 15pxtable-layout:auto\n位置和布局位置和布局的样式属性用于改变指定元素与其他元素的排列方式、显示方式等\ndisplay:block;visibility:hidden;float:left;clear:none;position:fixed;left,top,right,bottom:auto;cursor:auto;z-index:overflow:scroll;vertical-align:top;columns:auto1\n","categories":["code"],"tags":["css","前端"]},{"title":"HTML5学习之FileReader接口","url":"/2023/05/03/HTML5%E5%AD%A6%E4%B9%A0%E4%B9%8BFileReader%E6%8E%A5%E5%8F%A3/","content":"FileReader主要用于将文件内容读入内存，通过一系列异步接口，可以在主线程中访问本地文件。\n\n  使用FileReader对象，web应用程序可以异步的读取存储在用户计算机上的文件(或者原始数据缓冲)内容，可以使用File对象或者Blob对象来指定所要处理的文件或数据。\n\n\n创建实例   var reader = new FileReader()\nFileReader接口的方法   FileReader接口有4个方法，其中3个用来读取文件，另一个用来中断读取。无论读取成功或失败，方法并不会返回读取结果，这一结果存储在result属性中。\n\n\n\n\n方法名\n参数\n描述\n\n\n\n\nreadAsBinaryString\nfile\n将文件读取为二进制编码\n\n\nreadAsText\nfile,[encoding]\n将文件读取为文本\n\n\nreadAsDataURL\nfile\n将文件读取为DataURL\n\n\nabort\n(none)\n终端读取操作\n\n\n\n\nFileReader接口事件   FileReader接口包含了一套完整的事件模型，用于捕获读取文件时的状态。\n\n\n\n\n事件\n描述\n\n\n\n\nonabort\n中断\n\n\nonerror\n出错\n\n\nonloadstart\n开始\n\n\nonprogress\n正在读取\n\n\nonload\n成功读取\n\n\nonloadend\n读取完成，无论成功失败\n\n\n\n\nFileReader接口的使用   &lt;script type=&quot;text/javascript&quot;&gt;var result=document.getElementById(&quot;result&quot;);var file=document.getElementById(&quot;file&quot;);//判断浏览器是否支持FileReader接口if(typeof FileReader == &#x27;undefined&#x27;)&#123;    result.InnerHTML=&quot;&lt;p&gt;你的浏览器不支持FileReader接口！&lt;/p&gt;&quot;;    //使选择控件不可操作    file.setAttribute(&quot;disabled&quot;,&quot;disabled&quot;);&#125;function readAsDataURL()&#123;    //检验是否为图像文件    var file = document.getElementById(&quot;file&quot;).files[0];    if(!/image\\/\\w+/.test(file.type))&#123;        alert(&quot;看清楚，这个需要图片！&quot;);        return false;    &#125;    var reader = new FileReader();    //将文件以Data URL形式读入页面    reader.readAsDataURL(file);    reader.οnlοad=function(e)&#123;        var result=document.getElementById(&quot;result&quot;);        //显示文件        result.innerHTML=&#x27;&lt;img src=&quot;&#x27; + this.result +&#x27;&quot; alt=&quot;&quot; /&gt;&#x27;;    &#125;&#125;function readAsBinaryString()&#123;    var file = document.getElementById(&quot;file&quot;).files[0];    var reader = new FileReader();    //将文件以二进制形式读入页面    reader.readAsBinaryString(file);    reader.οnlοad=function(f)&#123;        var result=document.getElementById(&quot;result&quot;);        //显示文件        result.innerHTML=this.result;    &#125;&#125;function readAsText()&#123;    var file = document.getElementById(&quot;file&quot;).files[0];    var reader = new FileReader();    //将文件以文本形式读入页面    reader.readAsText(file);    reader.οnlοad=function(f)&#123;        var result=document.getElementById(&quot;result&quot;);        //显示文件        result.innerHTML=this.result;    &#125;&#125;&lt;/script&gt;&lt;p&gt;    &lt;label&gt;请选择一个文件：&lt;/label&gt;    &lt;input type=&quot;file&quot; id=&quot;file&quot; /&gt;    &lt;input type=&quot;button&quot; value=&quot;读取图像&quot; οnclick=&quot;readAsDataURL()&quot; /&gt;    &lt;input type=&quot;button&quot; value=&quot;读取二进制数据&quot; οnclick=&quot;readAsBinaryString()&quot; /&gt;    &lt;input type=&quot;button&quot; value=&quot;读取文本文件&quot; οnclick=&quot;readAsText()&quot; /&gt;&lt;/p&gt;&lt;div id=&quot;result&quot; name=&quot;result&quot;&gt;&lt;/div&gt;\nHTML5的一些基础知识\n\n\n\n分类\nHTML5新增元素预览\n\n\n\n\n结构元素\nsection, article, aside, header, hgroup, footer, nav, figure\n\n\n其他元素\nvideo, audio, embed, mark, progress, meter, time, ruby, rt, rp, whr, canvas, command, details, datalist, datagrid, keygen, output, source, menu\n\n\ninput类型元素\nemail, url, number, range, Date Pickers\n\n\n\n\n\n\n\n\n\nHTML5 新增属性\n作用\n\n\n\n\ncontentEditable\n可编辑属性\n\n\ndesignMode\n仅仅js调用编辑\n\n\nhidden\n隐藏元素\n\n\nspellcheck\n拼写语法检查\n\n\ntabindex\n按TAB键顺序改变\n\n\n\n\n\n\n\n\n\nHTML常用标签\n描述\n\n\n\n\n&lt;b&gt;\n粗体文本\n\n\n&lt;big\n大号字体\n\n\n&lt;em&gt;\n着重文字\n\n\n&lt;i&gt;\n斜体字\n\n\n&lt;small&gt;\n小号字\n\n\n&lt;strong&gt;\n加重语气\n\n\n&lt;sub&gt;\n下标字\n\n\n&lt;sup&gt;\n上标字\n\n\n&lt;ins&gt;\n插入字\n\n\n&lt;del&gt;\n删除字\n\n\n&lt;link&gt;\n外部样式表标签\n\n\n&lt;style&gt;\n内部样式表标签\n\n\n\n\n\n\n\n\n\n属性\n描述\n\n\n\n\nrel=”stylesheet”\n外部样式表\n\n\ntype=”text/css”\n引入文档的类型\n\n\nmargin-left\n边距\n\n\nBackground\n背景图片\n\n\nBgcolor\n背景颜色\n\n\n\n\n列表\n\n\n\n\n标签\n描述\n\n\n\n\n&lt;ol&gt;\n有序列表、属性：A, a, l, i, start\n\n\n&lt;ul&gt;\n无序列表、属性：disc, circle, square\n\n\n&lt;li&gt;\n列表项\n\n\n&lt;dl&gt;\n列表\n\n\n&lt;dt&gt;\n列表项\n\n\n&lt;dd&gt;\n描述\n\n\n\n\n表单标签\n\n\n\n\n标签\n描述\n\n\n\n\n&lt;form&gt;\n表单\n\n\n&lt;input&gt;\n输入域\n\n\n&lt;textarea&gt;\n文本域\n\n\n&lt;label&gt;\n控制标签\n\n\n&lt;fieldset&gt;\n定义域\n\n\n&lt;legend&gt;\n域的标题\n\n\n&lt;select&gt;\n选择列表\n\n\n&lt;optgroup&gt;\n选项组\n\n\n&lt;option&gt;\n下拉列表的选项\n\n\n&lt;button&gt;\n按钮\n\n\n\n\n表单新增属性\n\n\n\n\n新增属性\n描述\n\n\n\n\n标签的control\n标签内部表单元素的访问和改变\n\n\n文本框的placeholder\n提示文字，默认衬底\n\n\n文本框的list\n带输入的下拉菜单，紧跟&lt;datalist&gt;标签\n\n\n文本框的AutoComplete\n自动完成\n\n\n文本框的SelectionDirection\n获取用户选取文字方向\n\n\n文本框的pattern\n对于输入字符进行正则表达的判断\n\n\n复选框的indeterminate\n该属性用于初始化，表明尚未明确状态\n\n\nimage提交按钮的height和width\n控制图片按钮的大小\n\n\n\n\n","categories":["code"],"tags":["前端","html5"]},{"title":"matplotlib学习笔记","url":"/2023/05/03/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"InstallationMatplotlib releases are available as wheel packages for macOS, Windows and Linux on PyPI. Install it using pip:\npython -m pip install -U pippython -m pip install -U matplotlib\n\n\n  PS: Make sure you have installed the numpy\n\nuse pycharm to install directly\nA simple exampleMatplotlib graphs your data on Figures (i.e., windows, Jupyter widgets, etc.), each of which can contain one or more Axes (i.e., an area where points can be specified in terms of x-y coordinates, or theta-r in a polar plot, or x-y-z in a 3D plot, etc.). The simplest way of creating a figure with an axes is using pyplot.subplots. We can then use Axes.plot to draw some data on the axes:\nfig, ax = plt.subplots()ax.plot([1, 2, 3, 4], [1, 4, 2, 3])plt.show()\nParts of a FigureCustom PlotCustom function may be like as:\ndef my_plotter(ax, data1, data2, param_dict):    &quot;&quot;&quot;    A helper function to make a graph    Parameters    ----------    ax : Axes        The axes to draw to    data1 : array       The x data    data2 : array       The y data    param_dict : dict       Dictionary of kwargs to pass to ax.plot    Returns    -------    out : list        list of artists added    &quot;&quot;&quot;    out = ax.plot(data1, data2, **param_dict)    return out\nwhich you would then use as:\ndata1, data2, data3, data4 = np.random.randn(4, 100)fig, ax = plt.subplots(1, 1)my_plotter(ax, data1, data2, &#123;&#x27;marker&#x27;: &#x27;x&#x27;&#125;)\nMultiple subplotsimport numpy as npimport matplotlib.pyplot as plt\nx1 = np.linspace(0.0, 5.0)x2 = np.linspace(0.0, 2.0)y1 = np.cos(2 * np.pi * x1) * np.exp(-x1)y2 = np.cos(2 * np.pi * x2)fig, (ax1, ax2) = plt.subplots(2, 1)fig.suptitle(&#x27;A tale of 2 subplots&#x27;)ax1.plot(x1, y1, &#x27;o-&#x27;)ax1.set_ylabel(&#x27;Damped oscillation&#x27;)ax2.plot(x2, y2, &#x27;.-&#x27;)ax2.set_xlabel(&#x27;time (s)&#x27;)ax2.set_ylabel(&#x27;Undamped&#x27;)plt.show()\nImage Demoimport numpy as npimport matplotlib.cm as cmimport matplotlib.pyplot as pltimport matplotlib.cbook as cbookfrom matplotlib.path import Pathfrom matplotlib.patches import PathPatch# Fixing random state for reproducibilitynp.random.seed(19680801)\ndelta = 0.025x = y = np.arange(-3., 3., delta)X, Y = np.meshgrid(x, y)Z1 = np.exp(-X**2-Y**2)Z2 = np.exp(-(X--1)**2 - (Y--1)**2)Z = (Z1-Z2)*2fig, ax = plt.subplots()im = ax.imshow(Z, interpolation=&#x27;bilinear&#x27;, cmap=&#x27;rainbow&#x27;,               origin=&#x27;lower&#x27;, extent=[-3, 3, -3, 3],               vmax=abs(Z).max(), vmin=-abs(Z).max())plt.show()\nPolarr = np.arange(0, 2, 0.001)theta = 2 * np.pi * rfig, ax = plt.subplots(subplot_kw=&#123;&#x27;projection&#x27;: &#x27;polar&#x27;&#125;)ax.plot(theta, r)ax.set_rmax(2)ax.set_rticks([0.5, 1, 1.5, 2])  # less radial ticksax.set_rlabel_position(-22.5)  # Move radial labels away from plotted lineax.grid(True)ax.set_title(&#x27;A line plot on a polar axis&#x27;)plt.show()\nZoomdelta = 0.001x = y = np.arange(-3., 3., delta)extent = [-3, 3, -3, 3]X, Y = np.meshgrid(x, y)Z1 = np.exp(-X ** 2 - Y ** 2)Z2 = np.exp(-(X - -1) ** 2 - (Y - -1) ** 2)Z = (Z1 - Z2) * 2fig, ax = plt.subplots()im = ax.imshow(Z, interpolation=&#x27;bilinear&#x27;, cmap=&#x27;rainbow&#x27;,                       origin=&#x27;lower&#x27;, extent=extent,                       vmax=abs(Z).max(), vmin=-abs(Z).max())# inset axesaxins = ax.inset_axes([0.6, 0.6, 0.4, 0.4]) # location and enlarge factoraxins.imshow(Z, extent=extent, origin=&#x27;lower&#x27;, cmap=&#x27;rainbow&#x27;)# subregion of the original imagex1, x2, y1, y2 = -0.75, 0.25, -1.25, -0.25axins.set_xlim(x1, x2)axins.set_ylim(y1, y2)axins.set_xticklabels(&#x27;&#x27;)axins.set_yticklabels(&#x27;&#x27;)ax.indicate_inset_zoom(axins, edgecolor=&quot;black&quot;)plt.show()\nCode Hintingcommentsuse Type hinting\nfrom matplotlib import pyplot as pltimport matplotlib.axes._axes as axesimport matplotlib.figure as figurefig, ax = plt.subplots()  # type:figure.Figure, axes.Axesax.  # &lt;- now autocompletesfig.  # &lt;- now autocompletes\nuse assert isinstancefrom matplotlib import pyplot as pltimport matplotlib.axes._axes as axesimport matplotlib.figure as figurefig, ax = plt.subplots()assert isinstance(fig, figure.Figure)assert isinstance(ax, axes.Axes)ax.  # &lt;- now autocompletesfig.  # &lt;- now autocompletes\n","categories":["code"],"tags":["matplotlib","可视化","科研"]},{"title":"一些常用的googletest命令行参数","url":"/2023/05/03/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84googletest%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/","content":"单元测试时常用的命令行参数gtest_list_tests不执行单元测试用例，只是列出所有测试用例\ngtest_filter测试用例过滤器，挺有用，可以指定一些特定的测试用例执行，同时也可以指定一些测试用例不执行，同时还支持通配符，*匹配任何字串串，?匹配任何字符，:模式分隔符。如\n--gtest_filter=MYTEST.SUBTEST\ngtest_also_run_disabled_tests在gtest中，有一些单元测试出现了问题，你可以用gtest_filter过滤掉；在代码中可以过滤掉不要的单元测试用例，只要在加上前缀DISABLED_就可以过滤掉了，如果通过bugfix解决掉了相关问题，又要重新把禁用掉的单元测试跑起来，这个时候就可以用gtest_also_run_disabled_tests开启所有被disabled的用例。\ngtest_repeat这个最有用了，假设一个用例需要跑很多次才能测试出问题，又或者一个单元测试程序中有很多用例，而你只想跑其中一个用例很多遍，都可以这么用gtest_filter加gtest_repeat搞定；\n用负数指定次数表示死循环跑测试用例。\ngtets_color需要五彩斑斓的颜色不。\ngtest_print_time=0如果不需要每个测试用例的执行时间和总共的执行时间，可以关闭掉。\ngtest_break_on_failure，gtest_throw_on_failure可以让单元测试用例在失败的时候断点或者抛出异常，这对于使用VS开发来说非常重要，可以把代码停下来，看看各条线程正在做什么，对于命令行来说没什么用。\ngtest_catch_exceptions=0在单元测试用例中抛出异常，gtest框架是可以捕获的，使用这条参数就可以让异常终止程序的运行。\n","categories":["code"],"tags":["googletest","单元测试","命令行"]},{"title":"MySQL学习笔记","url":"/2023/05/03/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"终端操作进入数据库\nmysql -u root -p 123456\n如何查看有什么数据库 show databases;\nmysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || shop               || sys                |+--------------------+5 rows in set (0.00 sec)\n如何选择数据库 use shop如何查看该数据库中有哪些表mysql&gt; show tables;+--------------------------------------------+| Tables_in_shop                             |+--------------------------------------------+| adminmodules                               || auth_group                                 || auth_group_permissions                     || auth_permission                            || auth_user                                  || auth_user_groups                           || auth_user_user_permissions                 || course                                     || django_admin_log                           || django_content_type                        || django_migrations                          || django_session                             || login                                      || position                                   || product                                    || productcategory                            || registration_registrationprofile           || registration_supervisedregistrationprofile || saleslist                                  || saleslistdetail                            || score                                      || shop_position                              || student                                    || teacher                                    |+--------------------------------------------+24 rows in set (0.00 sec)\n如何查看表中的数据mysql&gt; select * from position;+------------+--------------+----------------------+| PositionId | PositionName | Description          |+------------+--------------+----------------------+|          1 | 管理员       | 负责管理超市！       ||          2 | 收银员       | 负责管理的收银工作！ |+------------+--------------+----------------------+2 rows in set (0.00 sec)\n如何退出数据库服务器 exit or ctrl+z如何在数据库中创建自己的数据库 create database dataBaseName如何创建数据表？petcreate table pet(name varchar(20),owner varchar(20),species varchar(20),sex char(1),birth datetime,death datetime);\n\n\nvar()与varchar()的区别在于var()是定常的,哪怕存储的字符串没有达到”()”中数字的上限,var()依然会占用空格来填充空间.而varchar()则是不定长的,没有达到”()”中的上限则会自动去掉后面的空格;\n\n性别不要用:sex 要用:gender 一个是性 一个是性别;\n\n定义最后一个字段的时候不要加”,”;\n上面的”VAR”,”VARCHAR”,”DATE”可以用小写.不过最好用大写来表示区分关键字,若不然也许写到后面你自己都不知道这个词是数据库中的关键字还是你自己自定义的一些数据,同时一定要用英文的标点符号也必须半角输入\n\n\n如何查看表的架构mysql&gt; desc product;+-------------+--------------+------+-----+---------+-------+| Field       | Type         | Null | Key | Default | Extra |+-------------+--------------+------+-----+---------+-------+| ProductId   | varchar(20)  | NO   | PRI | NULL    |       || BarCode     | varchar(20)  | YES  | UNI | NULL    |       || ProductName | varchar(100) | NO   |     | NULL    |       || Unit        | varchar(20)  | NO   |     | NULL    |       || UnitPrice   | float        | NO   |     | NULL    |       || CategoryId  | tinyint(4)   | YES  | MUL | NULL    |       || Inventory   | int(11)      | NO   |     | NULL    |       |+-------------+--------------+------+-----+---------+-------+7 rows in set (0.00 sec)\n如何插入数据INSERT INTO pet VALUES(&#x27;kk&#x27;,&#x27;cc&#x27;,&#x27;dog&#x27;,&#x27;1&#x27;,&#x27;1998-8-2&#x27;,null);INSERT INTO pet(name,owner) VALUES (&#x27;xx&#x27;,&#x27;cc&#x27;);\n\n\n\n\n\nname\nowner\nspecies\nsex\nbirth\ndeath\n\n\n\n\nkk\ncc\ndog\n1\n1998-08-02\nnull\n\n\n\n\n  NULL:代表的是空,表示该字段还没有数据.千万不要主动填写’NULL’,这代表你的字段有一个值叫做’null’.\n\nMYSQL常用类型\n  金钱最好用int/bigint,使用浮点会有精度损失\n\n如何删除数据\n删除 DELETE FROM tablename WHERE condition;\n修改 UPDATE tablename SET 字段1=值1,字段2=值2 ... WHERE 条件;\n\n表中的约束主键约束它能够唯一确定一张表中的一条记录,增加主键约束之后,就可以使得字段不重复而且不为空  \ncreate table user(    id int PRIMARY KEY,    name VARCHAR(20));INSERT INTO user VALUES (1,&#x27;张三&#x27;);+----+------+| id | name |+----+------+|  1 | 张三 |+----+------+运行DESCRIBE user;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id    | int(11)     | NO   | PRI | NULL    |       || name  | varchar(20) | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+发现 id是不可以为null 而且 key的值 也变为:PRI(primary)\n复合主键CREATE TABLE user2(    id INT,    name VARCHAR(20),    password VARCHAR(20),    PRIMARY key(id,name));运行DESCRIBE user2;+----------+-------------+------+-----+---------+-------+| Field    | Type        | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id       | int(11)     | NO   | PRI | NULL    |       || name     | varchar(20) | NO   | PRI | NULL    |       || password | varchar(20) | YES  |     | NULL    |       |+----------+-------------+------+-----+---------+-------+INSERT INTO user2 VALUES (1,&#x27;老王&#x27;,&#x27;123456&#x27;);INSERT INTO user2 VALUES (2,&#x27;老王&#x27;,&#x27;123456&#x27;);+----+------+----------+| id | name | password |+----+------+----------+|  1 | 老王 | 123456   ||  2 | 老王 | 123456   |+----+------+----------+\n只要所有的字段都不是相同的情况下可以允许其中的字段重复\n自增约束CREATE TABLE user3(    id INT PRIMARY KEY AUTO_INCREMENT,    name VARCHAR(20));运行DESCRIBE user3;+-------+-------------+------+-----+---------+----------------+| Field | Type        | Null | Key | Default | Extra          |+-------+-------------+------+-----+---------+----------------+| id    | int(11)     | NO   | PRI | NULL    | auto_increment || name  | varchar(20) | YES  |     | NULL    |                |+-------+-------------+------+-----+---------+----------------+INSERT INTO user3(name) VALUES(&#x27;张三&#x27;);INSERT INTO user3(name) VALUES(&#x27;李四&#x27;);+----+------+| id | name |+----+------+|  1 | 张三 ||  2 | 李四 |+----+------+没有自定义id值 但是自动生成了id\n唯一约束CREATE TABLE user5(    id INT PRIMARY KEY AUTO_INCREMENT,    name VARCHAR(20));运行 DESCRIBE user5;+-------+-------------+------+-----+---------+----------------+| Field | Type        | Null | Key | Default | Extra          |+-------+-------------+------+-----+---------+----------------+| id    | int(11)     | NO   | PRI | NULL    | auto_increment || name  | varchar(20) | YES  |     | NULL    |                |+-------+-------------+------+-----+---------+----------------+新增name为唯一约束:ALTER TABLE user5 ADD UNIQUE(name);运行 DESCRIBE user5;+-------+-------------+------+-----+---------+----------------+| Field | Type        | Null | Key | Default | Extra          |+-------+-------------+------+-----+---------+----------------+| id    | int(11)     | NO   | PRI | NULL    | auto_increment || name  | varchar(20) | YES  | UNI | NULL    |                |+-------+-------------+------+-----+---------+----------------+测试:插入数据INSERT INTO user5(name) VALUES (&#x27;cc&#x27;);运行 SELECT * FROM user5; 查看结果:+----+------+| id | name |+----+------+|  1 | cc   |+----+------+再次插入INSERT INTO user5(name) VALUES (&#x27;cc&#x27;);出现:ERROR 1062 (23000): Duplicate entry &#x27;cc&#x27; for key &#x27;name&#x27;换个试试 INSERT INTO user5(name) VALUES (&#x27;aa&#x27;);运行 SELECT * FROM user5; 查看结果:+----+------+| id | name |+----+------+|  3 | aa   ||  1 | cc   |+----+------+\n主键约束(primary key)中包含了唯一约束场景:设计一张用户注册表,用户姓名必须要用手机号来注册,而且手机号和用户名称都不能为空,那么:\nCREATE TABLE user_test(    id INT PRIMARY KEY AUTO_INCREMENT COMMENT&#x27;主键id&#x27;,    name VARCHAR(20) NOT NULL COMMENT&#x27;用户姓名,不能为空&#x27;,    phone_number VARCHAR(20) UNIQUE NOT NULL COMMENT&#x27;用户手机,不能重复且不能为空&#x27;);运行 DESCRIBE user_test;+--------------+-------------+------+-----+---------+----------------+| Field        | Type        | Null | Key | Default | Extra          |+--------------+-------------+------+-----+---------+----------------+| id           | int(11)     | NO   | PRI | NULL    | auto_increment || name         | varchar(20) | NO   |     | NULL    |                || phone_number | int(11)     | NO   | UNI | NULL    |                |+--------------+-------------+------+-----+---------+----------------+\n这样的话就达到了每一个手机号都只能出现一次,达到了每个手机号只能被注册一次.用户姓名可以重复,但是手机号码却不能重复,复合正常的逻辑需求\n非空约束name和phone_number都设置了非空,先只设置name参数不设置phone_number参数试一试INSERT INTO user_test (name) VALUES (&#x27;张三&#x27;);会出现Field &#x27;phone_number&#x27; doesn&#x27;t have a default value两个非空参数一起设置:INSERT INTO user_test (name,phone_number) VALUES (&#x27;张三&#x27;,&#x27;12345678901&#x27;);+----+------+--------------+| id | name | phone_number |+----+------+--------------+|  1 | 张三 | 12345678901  |+----+------+--------------+\n默认约束CREATE TABLE user6(   id int PRIMARY KEY AUTO_INCREMENT COMMENT&#x27;主键id&#x27;,    name VARCHAR(20) NOT NULL COMMENT&#x27;用户姓名不能为空&#x27;,    phone_number VARCHAR(20) NOT NULL COMMENT&#x27;用户手机号,不能为空&#x27;,    status INT DEFAULT 0 COMMENT&#x27;用户状态0:启用 1:禁封 默认:0&#x27;);运行DESCRIBE user6;+--------------+-------------+------+-----+---------+----------------+| Field        | Type        | Null | Key | Default | Extra          |+--------------+-------------+------+-----+---------+----------------+| id           | int(11)     | NO   | PRI | NULL    | auto_increment || name         | varchar(20) | NO   |     | NULL    |                || phone_number | varchar(20) | NO   |     | NULL    |                || status       | int(11)     | YES  |     | 0       |                |+--------------+-------------+------+-----+---------+----------------+插入数据:INSERT INTO user6(name,phone_number) VALUES (&#x27;aa&#x27;,&#x27;123&#x27;);INSERT INTO user6(name,phone_number) VALUES(&#x27;bb&#x27;,&#x27;1234&#x27;);INSERT INTO user6(name,phone_number) VALUES(&#x27;cc&#x27;,&#x27;1263456&#x27;);查看数据:SELECT * FROM user6;+----+------+--------------+--------+| id | name | phone_number | status |+----+------+--------------+--------+|  1 | aa   | 123          |      0 ||  2 | bb   | 1234         |      0 ||  3 | cc   | 1263456      |      0 |+----+------+--------------+--------+\n我们没有设置status的值,但是给我们创建了默认值0.\n应用场景:找正常的用户\n对这些正常用户进行发放优惠卷或者积分之类的东西,而被禁封的用户我们不让其参加多动.我们想要封用户只要将status的值从0改为1就行了,当然我们取用户的时候必须要先判断status是否是0.若是1.说明该用户已经被禁封.先封手机号为’1234’的用户:\nUPDATE user6 SET status = 1 WHERE phone_number= &#x27;1234&#x27;;SELECT * FROM user6;+----+------+--------------+--------+| id | name | phone_number | status |+----+------+--------------+--------+|  1 | aa   | 123          |      0 ||  2 | bb   | 1234         |      1 ||  3 | cc   | 1263456      |      0 |+----+------+--------------+--------+status为1,说明用户已经被封,该用户不可以参加活动我们取用户的时候加上status的判断,如:SELECT * FROM user6 WHERE status = 0;+----+------+--------------+--------+| id | name | phone_number | status |+----+------+--------------+--------+|  1 | aa   | 123          |      0 ||  3 | cc   | 1263456      |      0 |+----+------+--------------+--------+\n外键约束CREATE TABLE classes(    id INT PRIMARY KEY AUTO_INCREMENT COMMENT&#x27;班级表id&#x27;,    name VARCHAR(20) COMMENT&#x27;班级名称&#x27;);运行DESCRIBE classes;+-------+-------------+------+-----+---------+----------------+| Field | Type        | Null | Key | Default | Extra          |+-------+-------------+------+-----+---------+----------------+| id    | int(11)     | NO   | PRI | NULL    | auto_increment || name  | varchar(20) | YES  |     | NULL    |                |+-------+-------------+------+-----+---------+----------------+CREATE TABLE student(   id INT PRIMARY KEY AUTO_INCREMENT COMMENT&#x27;学生表id&#x27;,   name VARCHAR(20) COMMENT&#x27;学生姓名&#x27;,    class_id int COMMENT&#x27;教室id,这张表中的class_id是classes表中id的值&#x27;,    FOREIGN KEY (class_id) REFERENCES classes(id));//FOREIGN :外来  REFERENCES:应用,参考运行DESCRIBE student;+----------+-------------+------+-----+---------+----------------+| Field    | Type        | Null | Key | Default | Extra          |+----------+-------------+------+-----+---------+----------------+| id       | int(11)     | NO   | PRI | NULL    | auto_increment || name     | varchar(20) | YES  |     | NULL    |                || class_id | int(11)     | YES  | MUL | NULL    |                |+----------+-------------+------+-----+---------+----------------+\n班级插入数据:\nINSERT INTO CLASSES (name) VALUES (&#x27;一班&#x27;);INSERT INTO CLASSES (name) VALUES (&#x27;二班&#x27;);INSERT INTO CLASSES (name) VALUES (&#x27;三班&#x27;);INSERT INTO CLASSES (name) VALUES (&#x27;四班&#x27;);\n查看数据:\nSELECT * FROM classes;+----+------+| id | name |+----+------+|  1 | 一班 ||  2 | 二班 ||  3 | 三班 ||  4 | 四班 |+----+------+\n学生插入数据:\nINSERT INTO student (name,class_id) VALUES (&#x27;小赵&#x27;,1);INSERT INTO student (name,class_id) VALUES (&#x27;小钱&#x27;,2);INSERT INTO student (name,class_id) VALUES (&#x27;小孙&#x27;,3);INSERT INTO student (name,class_id) VALUES (&#x27;小李&#x27;,4);\n查看数据:\n+----+------+----------+| id | name | class_id |+----+------+----------+|  1 | 小赵 |        1 ||  2 | 小钱 |        2 ||  3 | 小孙 |        3 ||  4 | 小李 |        4 |+----+------+----------+\n若是像插入班级为5的数据 \n如:INSERT INTO student (name,class_id) VALUES (&#39;小周&#39;,5);\n报错:Cannot add or update a child row我们删除正在被学生表引用的’四班’试试:\nDELETE classes WHERE name = &#39;四班&#39;;\n出现:Cannot delete or update a parent row:不能删除主表中的行\n我们先删除学生表中的 ‘小李’从而解除班级中’四班’的外键约束,再来删除’四班’(因为小李引用了四班)\nDELETE FROM student WHERE name = &#39;小李&#39;;\n再次删除classes表中的’四班’\nDELETE FROM classes WHERE name = &#39;四班&#39;;\n最后: \nSELECT * FROM classes;+----+------+| id | name |+----+------+|  1 | 一班 ||  2 | 二班 ||  3 | 三班 |+----+------+\n‘四班’被成功删除!\n\n\n主表中没有的数据,在附表中,是不可以使用的.\n主表中记录的数据现在正在被附表所引用,那么主表中正在被引用的数据不可以被删除\n若要想删除,先将附表中的数据删除在删除主表数据\n对于外键约束大家可以联想 省,市 来进行联想 (市必须要依赖于省,只要省还有一个市在引用,那么就不可以删除省,要不然市就没有省了. 那么我们想删除省,必须要将该省下所有的市全部删除之后,才可以删除这个省)\n\n\n如何建表之后添加主键约束CREATE TABLE user4(    id INT,    name VARCHAR(20));mysql&gt; desc user;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id    | int(11)     | YES  |     | NULL    |       || name  | varchar(20) | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+\n加入主键约束ALTER TABLE user ADD PRIMARY KEY(id)后\nmysql&gt; ALTER TABLE user ADD PRIMARY KEY(id);Query OK, 0 rows affected (0.59 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc user;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id    | int(11)     | NO   | PRI | NULL    |       || name  | varchar(20) | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec)\n删除主键约束:ALTER TABLE user DROP PRIMARY KEY\nmysql&gt; ALTER TABLE user DROP PRIMARY KEY;Query OK, 0 rows affected (1.08 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc user;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id    | int(11)     | NO   |     | NULL    |       || name  | varchar(20) | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec)\n使用modify修改字段，添加约束ALTER TABLE user MODIFY id INT PRIMARY KEY\nmysql&gt; ALTER TABLE user MODIFY id INT PRIMARY KEY;Query OK, 0 rows affected (0.54 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc user;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id    | int(11)     | NO   | PRI | NULL    |       || name  | varchar(20) | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+\n给主键设置自增长:ALTER TABLE user4 MODIFY id INT AUTO_INCREMENT;\nmysql&gt; ALTER TABLE user MODIFY id INT AUTO_INCREMENT;Query OK, 0 rows affected (0.67 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc user;+-------+-------------+------+-----+---------+----------------+| Field | Type        | Null | Key | Default | Extra          |+-------+-------------+------+-----+---------+----------------+| id    | int(11)     | NO   | PRI | NULL    | auto_increment || name  | varchar(20) | YES  |     | NULL    |                |+-------+-------------+------+-----+---------+----------------+2 rows in set (0.00 sec)\n数据的增删改查\n增加INSERT INTO tablename [(indexes)] VAULES (values);\n删除DELETE tablename WHERE condition;\n修改UPDATE tablename SET index=value WHERE condition;\n查询SELECT items FROM tablename WHERE condition;\n\nMySQL的连接查询（4种）准备用于测试连接查询的数据：\nCREATE DATABASE testJoin;CREATE TABLE person (    id INT,    name VARCHAR(20),    cardId INT);CREATE TABLE card (    id INT,    name VARCHAR(20));INSERT INTO card VALUES (1, &#x27;饭卡&#x27;), (2, &#x27;建行卡&#x27;), (3, &#x27;农行卡&#x27;), (4, &#x27;工商卡&#x27;), (5, &#x27;邮政卡&#x27;);SELECT * FROM card;+------+-----------+| id   | name      |+------+-----------+|    1 | 饭卡      ||    2 | 建行卡    ||    3 | 农行卡    ||    4 | 工商卡    ||    5 | 邮政卡    |+------+-----------+INSERT INTO person VALUES (1, &#x27;张三&#x27;, 1), (2, &#x27;李四&#x27;, 3), (3, &#x27;王五&#x27;, 6);SELECT * FROM person;+------+--------+--------+| id   | name   | cardId |+------+--------+--------+|    1 | 张三   |      1 ||    2 | 李四   |      3 ||    3 | 王五   |      6 |+------+--------+--------+\n分析两张表发现，person 表并没有为 cardId 字段设置一个在 card 表中对应的 id 外键。如果设置了的话，person 中 cardId 字段值为 6 的行就插不进去，因为该 cardId 值在 card 表中并没有。\n内连接 inner join or join要查询这两张表中有关系的数据，可以使用 INNER JOIN ( 内连接 ) 将它们连接在一起。\n-- INNER JOIN: 表示为内连接，将两张表拼接在一起。-- on: 表示要执行某个条件。SELECT * FROM person INNER JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    |+------+--------+--------+------+-----------+-- 将 INNER 关键字省略掉，结果也是一样的。-- SELECT * FROM person JOIN card on person.cardId = card.id;\n\n  注意：card 的整张表被连接到了右边。\n\n左连接 left join or left outer ioin完整显示左边的表 ( person ) ，右边的表如果符合条件就显示，不符合则补 NULL 。\n-- LEFT JOIN 也叫做 LEFT OUTER JOIN，用这两种方式的查询结果是一样的。SELECT * FROM person LEFT JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    ||    3 | 王五   |      6 | NULL | NULL      |+------+--------+--------+------+-----------+\n右连接 right join or right outer join完整显示右边的表 ( card ) ，左边的表如果符合条件就显示，不符合则补 NULL 。\nSELECT * FROM person RIGHT JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    || NULL | NULL   |   NULL |    2 | 建行卡    || NULL | NULL   |   NULL |    4 | 工商卡    || NULL | NULL   |   NULL |    5 | 邮政卡    |+------+--------+--------+------+-----------+\n完全外连接 full join or full outer join完整显示两张表的全部数据。\n-- MySQL 不支持这种语法的全外连接-- SELECT * FROM person FULL JOIN card on person.cardId = card.id;-- 出现错误：-- ERROR 1054 (42S22): Unknown column &#x27;person.cardId&#x27; in &#x27;on clause&#x27;-- MySQL全连接语法，使用 UNION 将两张表合并在一起。SELECT * FROM person LEFT JOIN card on person.cardId = card.idUNIONSELECT * FROM person RIGHT JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    ||    3 | 王五   |      6 | NULL | NULL      || NULL | NULL   |   NULL |    2 | 建行卡    || NULL | NULL   |   NULL |    4 | 工商卡    || NULL | NULL   |   NULL |    5 | 邮政卡    |+------+--------+--------+------+-----------+\n事务在 MySQL 中，事务其实是一个最小的不可分割的工作单元。事务能够保证一个业务的完整性。\n比如我们的银行转账：\n-- a -&gt; -100UPDATE user set money = money - 100 WHERE name = &#x27;a&#x27;;-- b -&gt; +100UPDATE user set money = money + 100 WHERE name = &#x27;b&#x27;;\n在实际项目中，假设只有一条 SQL 语句执行成功，而另外一条执行失败了，就会出现数据前后不一致。\n因此，在执行多条有关联 SQL 语句时，事务可能会要求这些 SQL 语句要么同时执行成功，要么就都执行失败。\n如何控制事务 - COMMIT / ROLLBACK在 MySQL 中，事务的自动提交状态默认是开启的。\n-- 查询事务的自动提交状态SELECT @@AUTOCOMMIT;+--------------+| @@AUTOCOMMIT |+--------------+|            1 |+--------------+\n自动提交的作用：当我们执行一条 SQL 语句的时候，其产生的效果就会立即体现出来，且不能回滚。\n什么是回滚？举个例子：\nCREATE DATABASE bank;USE bank;CREATE TABLE user (    id INT PRIMARY KEY,    name VARCHAR(20),    money INT);INSERT INTO user VALUES (1, &#x27;a&#x27;, 1000);SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 |+----+------+-------+\n可以看到，在执行插入语句后数据立刻生效，原因是 MySQL 中的事务自动将它提交到了数据库中。那么所谓回滚的意思就是，撤销执行过的所有 SQL 语句，使其回滚到最后一次提交数据时的状态。\n在 MySQL 中使用 ROLLBACK 执行回滚：\n-- 回滚到最后一次提交ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 |+----+------+-------+\n由于所有执行过的 SQL 语句都已经被提交过了，所以数据并没有发生回滚。那如何让数据可以发生回滚？\n-- 关闭自动提交SET AUTOCOMMIT = 0;-- 查询自动提交状态SELECT @@AUTOCOMMIT;+--------------+| @@AUTOCOMMIT |+--------------+|            0 |+--------------+\n将自动提交关闭后，测试数据回滚：\nINSERT INTO user VALUES (2, &#x27;b&#x27;, 1000);-- 关闭 AUTOCOMMIT 后，数据的变化是在一张虚拟的临时数据表中展示，-- 发生变化的数据并没有真正插入到数据表中。SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 ||  2 | b    |  1000 |+----+------+-------+-- 数据表中的真实数据其实还是：+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 |+----+------+-------+-- 由于数据还没有真正提交，可以使用回滚ROLLBACK;-- 再次查询SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 |+----+------+-------+\n那如何将虚拟的数据真正提交到数据库中？使用 COMMIT :\nINSERT INTO user VALUES (2, &#x27;b&#x27;, 1000);-- 手动提交数据（持久性），-- 将数据真正提交到数据库中，执行后不能再回滚提交过的数据。COMMIT;-- 提交后测试回滚ROLLBACK;-- 再次查询（回滚无效了）SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 ||  2 | b    |  1000 |+----+------+-------+\n\n  总结\n\n自动提交\n\n查看自动提交状态：SELECT @@AUTOCOMMIT ；\n设置自动提交状态：SET AUTOCOMMIT = 0 。\n\n\n手动提交\n@@AUTOCOMMIT = 0 时，使用 COMMIT 命令提交事务。\n\n事务回滚\n@@AUTOCOMMIT = 0 时，使用 ROLLBACK 命令回滚事务。\n\n\n\n事务的实际应用，让我们再回到银行转账项目：\n-- 转账UPDATE user set money = money - 100 WHERE name = &#x27;a&#x27;;-- 到账UPDATE user set money = money + 100 WHERE name = &#x27;b&#x27;;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |   900 ||  2 | b    |  1100 |+----+------+-------+\n这时假设在转账时发生了意外，就可以使用 ROLLBACK 回滚到最后一次提交的状态：\n-- 假设转账发生了意外，需要回滚。ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 ||  2 | b    |  1000 |+----+------+-------+\n这时我们又回到了发生意外之前的状态，也就是说，事务给我们提供了一个可以反悔的机会。假设数据没有发生意外，这时可以手动将数据真正提交到数据表中：COMMIT 。\n手动开启事务 - BEGIN / START TRANSACTION事务的默认提交被开启 ( @@AUTOCOMMIT = 1 ) 后，此时就不能使用事务回滚了。但是我们还可以手动开启一个事务处理事件，使其可以发生回滚：\n-- 使用 BEGIN 或者 START TRANSACTION 手动开启一个事务-- START TRANSACTION;BEGIN;UPDATE user set money = money - 100 WHERE name = &#x27;a&#x27;;UPDATE user set money = money + 100 WHERE name = &#x27;b&#x27;;-- 由于手动开启的事务没有开启自动提交，-- 此时发生变化的数据仍然是被保存在一张临时表中。SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |   900 ||  2 | b    |  1100 |+----+------+-------+-- 测试回滚ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 ||  2 | b    |  1000 |+----+------+-------+\n仍然使用 COMMIT 提交数据，提交后无法再发生本次事务的回滚。\nBEGIN;UPDATE user set money = money - 100 WHERE name = &#x27;a&#x27;;UPDATE user set money = money + 100 WHERE name = &#x27;b&#x27;;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |   900 ||  2 | b    |  1100 |+----+------+-------+-- 提交数据COMMIT;-- 测试回滚（无效，因为表的数据已经被提交）ROLLBACK;\nACID 特征与使用事务的四大特征：\n\nA 原子性：事务是最小的单位，不可以再分割；\nC 一致性：要求同一事务中的 SQL 语句，必须保证同时成功或者失败；\nI 隔离性：事务1 和 事务2 之间是具有隔离性的；\nD 持久性：事务一旦结束 ( COMMIT ) ，就不可以再返回了 ( ROLLBACK ) 。\n\n事务的隔离性事务的隔离性可分为四种 ( 性能从低到高 ) ：\n\nREAD UNCOMMITTED ( 读取未提交 )\n如果有多个事务，那么任意事务都可以看见其他事务的未提交数据。\n\nREAD COMMITTED ( 读取已提交 )\n只能读取到其他事务已经提交的数据。\n\nREPEATABLE READ ( 可被重复读 )\n如果有多个连接都开启了事务，那么事务之间不能共享数据记录，否则只能共享已提交的记录。\n\nSERIALIZABLE ( 串行化 )\n所有的事务都会按照固定顺序执行，执行完一个事务后再继续执行下一个事务的写入操作。\n\n\n查看当前数据库的默认隔离级别：\n-- MySQL 8.x, GLOBAL 表示系统级别，不加表示会话级别。SELECT @@GLOBAL.TRANSACTION_ISOLATION;SELECT @@TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| REPEATABLE-READ                | -- MySQL的默认隔离级别，可以重复读。+--------------------------------+-- MySQL 5.xSELECT @@GLOBAL.TX_ISOLATION;SELECT @@TX_ISOLATION;\n修改隔离级别：\n-- 设置系统隔离级别，LEVEL 后面表示要设置的隔离级别 (READ UNCOMMITTED)。SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;-- 查询系统隔离级别，发现已经被修改。SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| READ-UNCOMMITTED               |+--------------------------------+\n脏读测试 READ UNCOMMITTED ( 读取未提交 ) 的隔离性：\nINSERT INTO user VALUES (3, &#x27;小明&#x27;, 1000);INSERT INTO user VALUES (4, &#x27;淘宝店&#x27;, 1000);SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 |+----+-----------+-------+-- 开启一个事务操作数据-- 假设小明在淘宝店买了一双800块钱的鞋子：START TRANSACTION;UPDATE user SET money = money - 800 WHERE name = &#x27;小明&#x27;;UPDATE user SET money = money + 800 WHERE name = &#x27;淘宝店&#x27;;-- 然后淘宝店在另一方查询结果，发现钱已到账。SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |   200 ||  4 | 淘宝店    |  1800 |+----+-----------+-------+\n由于小明的转账是在新开启的事务上进行操作的，而该操作的结果是可以被其他事务（另一方的淘宝店）看见的，因此淘宝店的查询结果是正确的，淘宝店确认到账。但就在这时，如果小明在它所处的事务上又执行了 ROLLBACK 命令，会发生什么？\n-- 小明所处的事务ROLLBACK;-- 此时无论对方是谁，如果再去查询结果就会发现：SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 |+----+-----------+-------+\n这就是所谓的脏读，一个事务读取到另外一个事务还未提交的数据。这在实际开发中是不允许出现的。\n读取已提交把隔离级别设置为 READ COMMITTED ：\nSET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| READ-COMMITTED                 |+--------------------------------+\n这样，再有新的事务连接进来时，它们就只能查询到已经提交过的事务数据了。但是对于当前事务来说，它们看到的还是未提交的数据，例如：\n-- 正在操作数据事务（当前事务）START TRANSACTION;UPDATE user SET money = money - 800 WHERE name = &#x27;小明&#x27;;UPDATE user SET money = money + 800 WHERE name = &#x27;淘宝店&#x27;;-- 虽然隔离级别被设置为了 READ COMMITTED，但在当前事务中，-- 它看到的仍然是数据表中临时改变数据，而不是真正提交过的数据。SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |   200 ||  4 | 淘宝店    |  1800 |+----+-----------+-------+-- 假设此时在远程开启了一个新事务，连接到数据库。$ mysql -u root -p12345612-- 此时远程连接查询到的数据只能是已经提交过的SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 |+----+-----------+-------+\n但是这样还有问题，那就是假设一个事务在操作数据时，其他事务干扰了这个事务的数据。例如：\n-- 小张在查询数据的时候发现：SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |   200 ||  4 | 淘宝店    |  1800 |+----+-----------+-------+-- 在小张求表的 money 平均值之前，小王做了一个操作：START TRANSACTION;INSERT INTO user VALUES (5, &#x27;c&#x27;, 100);COMMIT;-- 此时表的真实数据是：SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 ||  5 | c         |   100 |+----+-----------+-------+-- 这时小张再求平均值的时候，就会出现计算不相符合的情况：SELECT AVG(money) FROM user;+------------+| AVG(money) |+------------+|  820.0000  |+------------+\n虽然 READ COMMITTED 让我们只能读取到其他事务已经提交的数据，但还是会出现问题，就是在读取同一个表的数据时，可能会发生前后不一致的情况。\\这被称为*不可重复读现象 ( READ COMMITTED )* 。\n幻读将隔离级别设置为 REPEATABLE READ ( 可被重复读取 ) :\nSET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| REPEATABLE-READ                |+--------------------------------+\n测试 REPEATABLE READ ，假设在两个不同的连接上分别执行 START TRANSACTION :\n-- 小张 - 成都START TRANSACTION;INSERT INTO user VALUES (6, &#x27;d&#x27;, 1000);-- 小王 - 北京START TRANSACTION;-- 小张 - 成都COMMIT;\n当前事务开启后，没提交之前，查询不到，提交后可以被查询到。但是，在提交之前其他事务被开启了，那么在这条事务线上，就不会查询到当前有操作事务的连接。相当于开辟出一条单独的线程。\n无论小张是否执行过 COMMIT ，在小王这边，都不会查询到小张的事务记录，而是只会查询到自己所处事务的记录：\nSELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 ||  5 | c         |   100 |+----+-----------+-------+\n这是因为小王在此之前开启了一个新的事务 ( START TRANSACTION ) ,那么在他的这条新事务的线上，跟其他事务是没有联系的，也就是说，此时如果其他事务正在操作数据，它是不知道的。\n然而事实是，在真实的数据表中，小张已经插入了一条数据。但是小王此时并不知道，也插入了同一条数据，会发生什么呢？\nINSERT INTO user VALUES (6, &#x27;d&#x27;, 1000);-- ERROR 1062 (23000): Duplicate entry &#x27;6&#x27; for key &#x27;PRIMARY&#x27;\n报错了，操作被告知已存在主键为 6 的字段。这种现象也被称为幻读，一个事务提交的数据，不能被其他事务读取到。\n串行化顾名思义，就是所有事务的写入操作全都是串行化的。什么意思？把隔离级别修改成 SERIALIZABLE :\nSET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| SERIALIZABLE                   |+--------------------------------+\n还是拿小张和小王来举例：\n-- 小张 - 成都START TRANSACTION;-- 小王 - 北京START TRANSACTION;-- 开启事务之前先查询表，准备操作数据。SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 ||  5 | c         |   100 ||  6 | d         |  1000 |+----+-----------+-------+-- 发现没有 7 号王小花，于是插入一条数据：INSERT INTO user VALUES (7, &#x27;王小花&#x27;, 1000);\n此时会发生什么呢？由于现在的隔离级别是 SERIALIZABLE ( 串行化 ) ，串行化的意思就是：假设把所有的事务都放在一个串行的队列中，那么所有的事务都会按照固定顺序执行，执行完一个事务后再继续执行下一个事务的写入操作 ( 这意味着队列中同时只能执行一个事务的写入操作 ) 。\n根据这个解释，小王在插入数据时，会出现等待状态，直到小张执行 COMMIT 结束它所处的事务，或者出现等待超时。\n","categories":["code"],"tags":["SQL"]},{"title":"体系的概念","url":"/2023/05/03/%E4%BD%93%E7%B3%BB%E7%9A%84%E6%A6%82%E5%BF%B5/","content":"什么是体系（System of Systems，SoS）我们知道，系统（System）是相互关联的元素或部分组合在一起构成的整体。那什么是体系呢？体系是更高层次的系统，是系统的系统，由多个在功能上相对独立的系统构成，通过一定方式的协调组合，共同实现单个系统不具备且多个系统简单叠加也无法实现的综合能力和整体效能。由此可见，相对于系统来说，体系具有更高的复杂性。体系与系统的比较如下表所示。\n\n\n\n\n比较点\n体系\n系统\n\n\n\n\n能力需求\n功能和能力需求多样化\n功能和能力需求比较单一\n\n\n构成\n多个复杂系统集成\n由系统的组成部分构成\n\n\n规模\n规模庞大，全局的，地理分布范围广泛\n规模较小，区域的，分布比较集中\n\n\n边界\n边界不明确，体系间有较强交互\n边界明确，系统间较少交互\n\n\n组件关系\n系统间松耦合，协同工作，相互补充\n组件间紧耦合，相互依赖，缺一不可\n\n\n复杂性\n层次结构和组件关联方式复杂\n层次结构和组件关联方式简单\n\n\n生命周期\n不确定，无限长的生命周期\n比较确定，固定的生命周期\n\n\n优化\n很复杂，较难优化\n在公认的指标上优化\n\n\n信息流\n潜在改变的信息流和普遍的信息共享\n很好理解的信息流\n\n\n演化性\n随需求和技术的变化不断演化发展\n较少改进，注重系统自身功能的提高\n\n\n采办开发\n由多个权力机构控制开发\n单个权力机构开发\n\n\n\n\n什么体系架构（System of Systems Architecture，SoSA）要理解体系架构的概念，首先需要搞清楚什么是架构（Architecture）。通俗地讲，架构是经过系统性地思考，权衡利弊之后在现有资源约束下的最合理决策，最终明确的系统骨架。架构包括子系统、模块、组件，以及他们之间协作关系、约束规范、指导原则。\n那什么体系架构呢？计算机领域也有体系架构的概念，我们这里只在系统科学范畴讨论体系架构。体系架构通常也称为体系结构，它是系统各组分的结构、它们之间的关系以及指导其设计和随时间演化的原则与指南。体系架构表现了体系组成及其相互关系，明确了系统之间的边界、接口和约束关系，科学地勾画了体系的建设蓝图。利用体系架构可以指导体系的顶层规划、设计、论证和实现，实现各种系统的综合集成，提高系统之间的互操作，同时也可以指导体系的运行。\n什么是体系架构框架（System of Systems Architecture Framework，SoSAF）我们还是先来理解一下框架（Framework）的概念。在软件领域，框架是组件实现的规范，例如：MVC、MVP、MVVM等框架，是提供基础功能的产品，例如开源框架：Ruby on Rails、Spring、Laravel、Django等，这是可以拿来直接使用或者在此基础上二次开发。由此可见，框架为了实现某个业界标准或完成特定基本任务的软件组件规范，按照规范提供所要求基础功能的软件产品。\n体系架构框架是用于体系结构描述的方法、过程、视角、模型的集合。体系结构框架为体系结构描述提供一个统一框架，在这个框架下，建模人员从不同视角和关注点来收集获取体系结构数据，为分类、组织体系结构数据提供依据，并为体系结构模型的开发提供过程指导以及原则指南，确保对体系结构的理解、比较和集成有一个统一的标准。目前知名的体系架构框架有：The Open Group提出的TOGAF、美国国防部提出的DoDAF、英国国防部提出的MoDAF、北约的NAF、对象管理组织提出的统一体系架构框架UAF等。\n什么是体系工程（System of Systems Engineering，SoSE）为了应对“体系”在规划设计、分析、组织、集成过程中出现的一系列新问题，如|互联、互通、互操作、复杂性、导向涌现性、发展演化性等问题，研究人员在系统工程的理论基础上，提出了体系工程的概念。与系统工程相比，体系工程更注重研究复杂大系统的体系结构、各组分之问的相互协调与相互操作问题、与环境的关系以及体系的发展和演化问题，更注重体系整体能力的提升。由此可见，体系工程是通过设计、开发和集成复杂大系统来完成特定任务并获得期望的效果，实现能力、使命或期望结果的理论、方法和技术。\n[[从“基于模型”到“基于模型和仿真”的系统架构设计建模——通过仿真实现高质量系统定义]]\n","categories":["工作"],"tags":["建模"]},{"title":"忘记sql密码怎么办","url":"/2023/05/03/%E5%BF%98%E8%AE%B0sql%E5%AF%86%E7%A0%81%E6%80%8E%E4%B9%88%E5%8A%9E/","content":"日常工作中我们总会遇见忘记sql密码，这时我们只要做到如下几步：\n\n关闭sql\n跳过权限表\n重置密码\n重启sql\n\n\n关闭sql以管理员身份打开cmd输入：\nnet stop sql\n跳过权限表在命令行窗口输入：\nmysqld --skip-grant-tables\n重置密码\n打开另一个cmd窗口，输入mysql进入数据库\n输入show databases;看到数据库说明进入成功\n权限表放在mysql.user中\n输入SELECT user, host, plugin, authentication_string from mysql.user;可以看见用户和加密后的密码\n  注意，plugin插件代表加密方式，mysql自带的是mysql_native_password\n\n\n更改root密码，输入update user set password=password(&#39;123456&#39;) where user=&#39;root&#39; and host=&#39;localhost&#39;;\n再次查看密码，输入SELECT user, host, plugin, authentication_string from mysql.user;\n\n重启mysql\n关闭cmd，并手动停止mysqld的运行\n输入net start mysql重启mysql\n输入’mysql -u root -p 123456’登录mysql\n\n","categories":["code"],"tags":["SQL","密码"]},{"title":"星の在り処","url":"/2023/05/03/%E6%98%9F%E4%B9%8B%E6%89%80%E5%9C%A8/","content":"歌：う～み chorus :伊藤和子英雄传说6 空之轨迹 theme\n君の影 星のように朝に溶けて消えていく行き先を失くしたまま想いは溢れてくる强さにも弱さにもこの心は向き合えた君とならどんな明日が来ても怖くないのに二人步いた时を信じていて欲しい真实も嘘もなく夜が明けて朝が来る星空が朝に溶けても君の辉きはわかるよ\nさよならを知らないで梦见たのは 一人きりあの顷の君の目には何が映っていたの？二人つないだ时を谁も消せはしない孤独とか痛みとかどんな君も感じたいもう一度见つめ合えば愿(ねが)いはきっと叶(かな)う\n夜明け前 まどろみに风が颊を流れていく君の声君の香りが全てを包んで满ちていく思い出を羽ばたかせ君の空へ舞い上がる星空が朝に溶けても爱してる ただそれだけで二人はいつかまた会える\n","categories":["ANIME"],"tags":["歌词","恋爱"]},{"title":"恋人を射ち堕とした日","url":"/2023/05/03/%E6%81%8B%E4%BA%BA%E3%82%92%E5%B0%84%E3%81%A1%E5%A0%95%E3%81%A8%E3%81%97%E3%81%9F%E6%97%A5/","content":"二本目（にぼんめ）の記憶（きおく）弓（ゆみ）がしなり弾（はじ）けた焔（ほのお）夜空（よぞら）を凍（こお）らせて凛（りん）と青く別（わか）れの歌を恋人を射ち落とす（うちおとす）遠（とお）い日の忘れ物引（ひ）き咲かれた傷痕（きずあと）呪（のろ）われし約束をその胸（むね）に宿（やど）して「避（さ）けれれぬ終焉（しゅうえん）は、せめて愛（いと）しいその手（て）で」抗（あらが）えぬ衝動（しょうどう）の闇（やみ）が彼をつづんだ歪（ゆが）む世界    螺旋（らせん）の焔    輪回（りんね）を貫（つらぬ）いで凛と赤（あか）く血濡（ちぬ）れくちづけアナタを射ち落とす（忘レモノハ有（あ）リマセンカ？）｛古（いにしえ）の伝説（でんせつ）　その魔物傷を負わされた物は｝｛呪いが全身（ぜんしん）を駆（か）け周（まわ）り｝｛やがては同（おな）じ魔物に成（な）り果（は）てるだろう｝（その傷を負ったのはいつ・・・）｛それは二人が出会ったあの日まで遡（さかのぼ）る｝｛彼が彼女を助（たす）けた時に負った傷｝｛全ては出会った時から始まっていた｝（出会いは喪失（そうしつ）への約束）｛枯（か）れ果てた涙（なみだ）は｝｛悲（かな）しみの青い炎（ほのお）を宿（やど）し｝｛銀色（いろ）に輝（かがや）く矢（や）を放（はな）つ｝｛何度でも　ただ彼が息絶（いきた）えるまで｝愛する人を失（うしな）った世界にはどんな色の花が咲くのだろう？月を抱（いだ）いた十字（じゅうじ）の焔（ほのお）茨（いばら）を巻（ま）きつけて凛と白（しろ）く最後（さいご）の弓矢（アロー）私を射（う）ち落（お）とす\n","categories":["ANIME"],"tags":["歌词","恋爱"]},{"title":"狄拉克符号","url":"/2023/05/03/%E7%8B%84%E6%8B%89%E5%85%8B%E7%AC%A6%E5%8F%B7/","content":"概念\n狄拉克符号是将Hilbert空间分为右矢(bra)空间和左矢(ket)空间\n右矢和左矢分别记作和\n\n\n两条原则\n只描述抽象的特殊的态，而不涉及具体的表象，可直接用右矢标记。这里表象可以理解为“坐标系”的意思。\n\n例如：  表示波函数描述的状态， 表示坐标本征值为的本征态，是能量为的能量本征态……这类表示方法，均不涉及具体表象，通常用于直接描述本征态。\n\n表象中的简洁运算\n\n\n狄拉克内积可表示为 ，且有 \n外积 \n\n若左矢和右矢相互正交，则 ，若  归一化过，则 \n在表象F下，存在完全集 ，则任一态矢量  按照基矢  的展开可以记作\n\n|\\psi\\rangle = \\sum\\limits_{k}{a_k \\ |k\\rangle}由于基矢是完备正交的，因此矢量 在其上的基投影量记作 ，对于基矢本身有\n\n\\mathbf I = \\sum\\limits_{k} {|k \\rangle \\langle k|}关于狄拉克符号的一些简洁的记法\n算符：\n本征方程：\n薛定谔方程：\n力学量平均：\n\n假定F表象的基矢记作 ，L表象的基矢记作 ，对于一个量子态 ，两个表象下分别表示为\n\n|\\varphi\\rangle = \\sum\\limits_{f} a_f |f\\rangle \\\\\n|\\varphi\\rangle = \\sum\\limits_{l} a_l |l\\rangle而从表象F到表象L的变换可记作\n\n\\langle f|\\psi \\rangle = \\sum\\limits_{l} \\langle f|l \\rangle \\langle l|\\psi\\rangle即 \n","categories":["数学"],"tags":["狄拉克","矢量"]},{"title":"爱因斯坦求和","url":"/2023/05/03/%E7%88%B1%E5%9B%A0%E6%96%AF%E5%9D%A6%E6%B1%82%E5%92%8C/","content":"einsum记法如果你像我一样，发现记住PyTorch/TensorFlow中那些计算点积、外积、转置、矩阵-向量乘法、矩阵-矩阵乘法的函数名字和签名很费劲，那么einsum记法就是我们的救星。einsum记法是一个表达以上这些运算，包括复杂张量运算在内的优雅方式，基本上，可以把einsum看成一种领域特定语言。一旦你理解并能利用einsum，除了不用记忆和频繁查找特定库函数这个好处以外，你还能够更迅速地编写更加紧凑、高效的代码。而不使用einsum的时候，容易出现引入不必要的张量变形或转置运算，以及可以省略的中间张量的现象。此外，einsum这样的领域特定语言有时可以编译到高性能代码，事实上，PyTorch最近引入的能够自动生成GPU代码并为特定输入尺寸自动调整代码的张量理解（Tensor Comprehensions）就基于类似einsum的领域特定语言。此外，可以使用opt einsum和tf einsum opt这样的项目优化einsum表达式的构造顺序。比方说，我们想要将两个矩阵  和  相乘，接着计算每列的和，最终得到向量 。使用爱因斯坦求和约定，这可以表达为：\n\n{\\huge {\\color{SeaGreen} c_{j}} \n=\\sum_{i} \\sum_{k} {\\color{ProcessBlue} A_{i k}}  {\\color{Lavender} B_{k j}} \n={\\color{ProcessBlue} A_{i k}} {\\color{Lavender} B_{k j}} \\cdot\n}这一表达式指明了中的每个元素$c{i}是如何计算的，列向量\\mathbf A{i:}乘以行向量\\mathbf B_{:j}，然后求和。注意，在爱因斯坦求和约定中，我们省略了求和符号{\\large}\\Sigma，因为我们隐式地累加重复的下标（这里是k）和输出中未指明的下标（这里是i$ ）。当然，einsum也能表达更基本的运算。比如，计算两向量 的点积可以表达为：\n\n{\\huge {\\color{SeaGreen} c} \n=\\sum_{i} {\\color{ProcessBlue} a_{i}}  {\\color{Lavender} b_{i}} \n={\\color{ProcessBlue} a_{i}} {\\color{Lavender} b_{i}} \\cdot}在深度学习中，我经常碰到的一个问题是，变换高阶张量到向量。例如，我可能有一个张量，其中包含一个batch中的个训练样本，每个样本是一个长度为的维词向量序列，我想把词向量投影到一个不同的维度  。如果将这个张量记作 ，将投影矩阵记作 ，那么所需计算可以用einsum表达为：\n\n{\\huge {\\color{SeaGreen} C_{ntq}}\n=\\sum_{k} {\\color{ProcessBlue} T_{ntk} {\\color{Lavender} W_{kq}}}\n= {\\color{ProcessBlue} T_{ntk}} {\\color{Lavender} W_{kq}} \\cdot\n}最后一个例子，比方说有一个四阶张量  ，我们想要使用之前的投影矩阵将第三维投影至维，并累加第二维，然后转置结果中的第一维和最后一维，最终得到张量 。einsum可以非常简洁地表达这一切：\n\n{\\huge {\\color{SeaGreen} C_{mqn}}\n=\\sum_{t} \\sum_{k}{\\color{ProcessBlue} T_{ntkm} {\\color{Lavender} W_{kq}}}\n= {\\color{ProcessBlue} T_{ntkm}} {\\color{Lavender} W_{kq}} \\cdot\n}注意，我们通过交换下标和（而不是），转置了张量构造结果。\nNumpy、PyTorch、TensorFlow中的einsum [[numpy]]einsum在numpy中实现为np.einsum，在PyTorch中实现为torch.einsum，在TensorFlow中实现为tf.einsum，均使用一致的签名einsum(equation, operands)，其中equation是表示爱因斯坦求和约定的字符串，而operands则是张量序列（在numpy和TensorFlow中是变长参数列表，而在PyTorch中是列表）。例如，我们的第一个例子， $cj = \\sum{i}\\sum{k} A{ik}B_{kj}$ 写成equation字符串就是ik,kj -&gt; j。注意这里(i, j, k)的命名是任意的，但需要一致。\nPyTorch和TensorFlow像numpy支持einsum的好处之一是einsum可以用于神经网络架构的任意计算图，并且可以反向传播。典型的einsum调用格式如下：\nresult = numpy.einsum(\"ij,ijk,ij-&gt;ik\", arg1, arg2, arg3)\n\n{\\huge {\\color{SeaGreen}\\textbf{reslult}}\n= \\text{einsum}(\"\n{\\color{Red}\\Box\\Box},\\ {\\color{ProcessBlue}\\Box\\Box\\Box},\\ {\\color{Lavender}\\Box\\Box}\n\", {\\color{Red} arg1},\\ {\\color{ProcessBlue}arg2},\\ {\\color{Lavender}agr3} )\n}上式中是占位符，表示张量维度。上面的例子中，arg1和arg3是矩阵，arg2是二阶张量，这一einsum运算的结果（result）是矩阵。注意einsum处理的是可变数量的输入。在上面的例子中，einsum指定了三个参数之上的操作，但它同样可以用在牵涉一个参数、两个参数、三个以上参数的操作上。学习einsum的最佳途径是通过学习一些例子，所以下面我们将展示一下，在许多深度学习模型中常用的库函数，用einsum该如何表达（以PyTorch为例）。\n矩阵转置\n{\\huge {\\color{SeaGreen}B_{ji} = {\\color{Lavender}A_{ij}}}}import torcha = torch.arange(6).reshape(2, 3)torch.einsum('ij-&gt;ji', [a])tensor([[ 0.,  3.],        [ 1.,  4.],        [ 2.,  5.]])\n求和\n{\\huge {\\color{SeaGreen}b} =\\sum_{i}\\sum_{j}  {\\color{Lavender}A_{ij}}}a = torch.arange(6).reshape(2, 3)torch.einsum('ij-&gt;', [a])tensor(15.)\n列求和\n{\\huge {\\color{SeaGreen}b_j} = \\sum_{i} {\\color{Lavender}A_{ij}}}a = torch.arange(6).reshape(2, 3)torch.einsum('ij-&gt;j', [a])tensor([ 3.,  5.,  7.])\n行求和\n{\\huge {\\color{SeaGreen}b_i} = \\sum_{j} {\\color{Lavender}A_{ij}}}a = torch.arange(6).reshape(2, 3)torch.einsum('ij-&gt;i', [a])tensor([  3.,  12.])\n矩阵-向量相乘\n{\\huge {\\color{SeaGreen}C_i} \n= \\sum_{k} {\\color{Lavender}A_{ik}} {\\color{ProcessBlue}b_k}}a = torch.arange(6).reshape(2, 3)b = torch.arange(3)torch.einsum('ik,k-&gt;i', [a, b])tensor([  5.,  14.])\n矩阵-矩阵相乘\n{\\huge{\\color{SeaGreen}C_{ij}}\n=\\sum_{k} {\\color{Lavender}A_{ik} {\\color{ProcessBlue}B_{kj}}}\n}a = torch.arange(6).reshape(2, 3)b = torch.arange(15).reshape(3, 5)torch.einsum('ik,kj-&gt;ij', [a, b])tensor([[  25.,   28.,   31.,   34.,   37.],        [  70.,   82.,   94.,  106.,  118.]])\n点积 向量:\n\n{\\huge {\\color{SeaGreen}c} \n= \\sum_{i} {\\color{Lavender}a_i} {\\color{ProcessBlue}b_i}\n}a = torch.arange(3)b = torch.arange(3,6)  # [3, 4, 5]torch.einsum('i,i-&gt;', [a, b])tensor(14.)\n矩阵：\n\n{\\huge {\\color{SeaGreen}c} \n= \\sum_{i}\\sum_{j} {\\color{Lavender}A_{ij}} {\\color{ProcessBlue}B_{ij}}\n}a = torch.arange(6).reshape(2, 3)b = torch.arange(6,12).reshape(2, 3)torch.einsum('ij,ij-&gt;', [a, b])tensor(145.)\n哈达玛积\n{\\huge {\\color{SeaGreen}C_{ij}} \n= {\\color{Lavender}A_{ij}} {\\color{ProcessBlue}B_{ij}}\n}\\\\\n{\\huge {\\color{SeaGreen}\\mathbf C} = {\\color{Lavender}\\mathbf A} \\circ {\\color{ProcessBlue}\\mathbf B}}a = torch.arange(6).reshape(2, 3)b = torch.arange(6,12).reshape(2, 3)torch.einsum('ij,ij-&gt;ij', [a, b])tensor([[  0.,   7.,  16.],        [ 27.,  40.,  55.]])\n外积\n{\\huge {\\color{SeaGreen}C_{ij}} \n= {\\color{Lavender}a_{i}} {\\color{ProcessBlue}b_{j}}\n}a = torch.arange(3)b = torch.arange(3,7)torch.einsum('i,j-&gt;ij', [a, b])tensor([[  0.,   0.,   0.,   0.],        [  3.,   4.,   5.,   6.],        [  6.,   8.,  10.,  12.]])\nbatch矩阵相乘\n{\\huge {\\color{SeaGreen}C_{ijl}} \n= \\sum_{k}{\\color{Lavender}A_{ijk}} {\\color{ProcessBlue}B_{ikl}}\n}a = torch.randn(3,2,5)b = torch.randn(3,5,3)torch.einsum('ijk,ikl-&gt;ijl', [a, b])tensor([[[ 1.0886,  0.0214,  1.0690],         [ 2.0626,  3.2655, -0.1465]],        [[-6.9294,  0.7499,  1.2976],         [ 4.2226, -4.5774, -4.8947]],        [[-2.4289, -0.7804,  5.1385],         [ 0.8003,  2.9425,  1.7338]]])\n张量缩约batch矩阵相乘是张量缩约的一个特例。比方说，我们有两个张量，一个阶张量，一个阶张量。举例来说，我们取，并假定且。我们可以将这两个张量在这两个维度上相乘（A张量的第2、3维度，B张量的3、5维度），最终得到一个新张量，如下所示：\n\n{\\huge {\\color{SeaGreen}C_{pstuv}} \n= \\sum_{q} \\sum_{r} {\\color{Lavender}A_{pqrs}} {\\color{ProcessBlue}B_{tuqvr}}\n}a = torch.randn(2,3,5,7)b = torch.randn(11,13,3,17,5)torch.einsum('pqrs,tuqvr-&gt;pstuv', [a, b]).shapetorch.Size([2, 7, 11, 13, 17])\n双线性变换如前所述，einsum可用于超过两个张量的计算。这里举一个这方面的例子，双线性变换。\n\n{\\huge {\\color{SeaGreen}D_{ij}} \n= \\sum_{k} \\sum_{l}{\\color{Lavender}A_{ik}} {\\color{ProcessBlue}B_{jkl} {\\color{Orange}C_{il}}}\n}a = torch.randn(2,3)b = torch.randn(5,3,7)c = torch.randn(2,7)torch.einsum('ik,jkl,il-&gt;ij', [a, b, c])tensor([[ 3.8471,  4.7059, -3.0674, -3.2075, -5.2435],        [-3.5961, -5.2622, -4.1195,  5.5899,  0.4632]])\n案例TreeQN我曾经在实现TreeQN（ arXiv:1710.11417）的等式6时使用了einsum：给定网络层l上的低维状态表示和激活上的转换函数，我们想要计算残差链接的下一层状态表示。\n\n{\\huge \\mathbf z_{l+1}^{a}\n=\\mathbf z_l + \\tanh(\\mathbf W^{a} \\mathbf z_l)}在实践中，我们想要高效地计算大小为B的batch中的维状态表示，并同时计算所有转换函数（即，所有激活A）。我们可以将这些转换函数安排为一个张量，并使用einsum高效地计算下一层状态表示。\nimport torch.nn.functional as Fdef random_tensors(shape, num=1, requires_grad=False):  tensors = [torch.randn(shape, requires_grad=requires_grad) for i in range(0, num)]  return tensors[0] if num == 1 else tensors# 参数# -- [激活数 x 隐藏层维度]b = random_tensors([5, 3], requires_grad=True)# -- [激活数 x 隐藏层维度 x 隐藏层维度]W = random_tensors([5, 3, 3], requires_grad=True)def transition(zl):    # -- [batch大小 x 激活数 x 隐藏层维度]    return zl.unsqueeze(1) + F.tanh(torch.einsum(\"bk,aki-&gt;bai\", [zl, W]) + b)# 随机取样仿造输入# -- [batch大小 x 隐藏层维度]zl = random_tensors([2, 3])transition(zl)\n注意力让我们再看一个使用einsum的真实例子，实现注意力机制的等式11-13（arXiv:1509.06664）：\n\n{\\huge \\mathbf M_t \n= \\tanh(\\mathbf W^y \\mathbf Y + (\\mathbf W^h \\mathbf h_t + \\mathbf W^r \\mathbf r_{t-1})\\otimes \\mathbf e_L)\\qquad \\mathbf M_t\\in\\mathbb R^{k\\times L}}\\\\\n{\\huge \\alpha_t \n= \\text{softmax}(\\mathbf w^T \\mathbf M_t)\\qquad \\mathbf \\alpha_t\\in\\mathbb R^{ L}}\\\\\n{\\huge \\mathbf r_t \n= \\mathbf Y \\alpha_{t}^{T}+\\tanh(\\mathbf W^t \\mathbf r_{t-1})\\qquad \\mathbf r_t\\in\\mathbb R^{k}}\\\\用传统写法实现这些可要费不少力气，特别是考虑batch实现。einsum是我们的救星！\n# 参数# -- [隐藏层维度]bM, br, w = random_tensors([7], num=3, requires_grad=True)# -- [隐藏层维度 x 隐藏层维度]WY, Wh, Wr, Wt = random_tensors([7, 7], num=4, requires_grad=True)# 注意力机制的单次应用def attention(Y, ht, rt1):    # -- [batch大小 x 隐藏层维度]    tmp = torch.einsum(\"ik,kl-&gt;il\", [ht, Wh]) + torch.einsum(\"ik,kl-&gt;il\", [rt1, Wr])    Mt = F.tanh(torch.einsum(\"ijk,kl-&gt;ijl\", [Y, WY]) + tmp.unsqueeze(1).expand_as(Y) + bM)    # -- [batch大小 x 序列长度]    at = F.softmax(torch.einsum(\"ijk,k-&gt;ij\", [Mt, w]))    # -- [batch大小 x 隐藏层维度]    rt = torch.einsum(\"ijk,ij-&gt;ik\", [Y, at]) + F.tanh(torch.einsum(\"ij,jk-&gt;ik\", [rt1, Wt]) + br)    # -- [batch大小 x 隐藏层维度], [batch大小 x 序列维度]    return rt, at# 取样仿造输入# -- [batch大小 x 序列长度 x 隐藏层维度]Y = random_tensors([3, 5, 7])# -- [batch大小 x 隐藏层维度]ht, rt1 = random_tensors([3, 7], num=2)rt, at = attention(Y, ht, rt1)\n总结einsum是一个函数走天下，是处理各种张量操作的瑞士军刀。话虽如此，einsum满足你一切需要显然夸大其词了。从上面的真实用例可以看到，我们仍然需要在einsum之外应用非线性和构造额外维度（unsqueeze）。类似地，分割、连接、索引张量仍然需要应用其他库函数。\n使用einsum的麻烦之处是你需要手动实例化参数，操心它们的初始化，并在模型中注册这些参数。不过我仍然强烈建议你在实现模型时，考虑下有哪些情况适合使用einsum.\n","categories":["数学"],"tags":["Einstein","机器学习"]},{"title":"辞退职场“老实人”（上）","url":"/2023/05/03/%E8%BE%9E%E9%80%80%E8%81%8C%E5%9C%BA%E2%80%9C%E8%80%81%E5%AE%9E%E4%BA%BA%E2%80%9D%EF%BC%88%E4%B8%8A%EF%BC%89/","content":"初遇“老实人”老实人曾经和我一个组，平级同事，日常谨小慎微，不善言辞，看起来一副踏实肯干，职场老实人的样子，日常是前领导的小宝贝，每天看起来忙忙碌碌，但最后其实什么也没干。能力上和刚工作6个月的非本专业新人大专生媲美（老实人是博士退学转硕），但由于躺在公司最重要的项目上，周围的人不得不扶着这位走到终点，加上前领导Q偏爱，于是年年优秀拿到手软，也是公司的老员工了。我来公司不久，就和一部分员工被抽调组建新的部门，他也本应是被抽调的一员，但在前领导Q的强烈要求下（他工作能力不行，还是留在我这吧）留在了原部门，对你没看错，前领导Q知道他能力不行，依然是当年的优秀，直到前领导Q因部门没有产出，经常推卸本部门责任与其他部门摩擦等原因，被公司劝退了。树倒猢狲散，部门被拆分，老实人也被塞到了我组。\n我和老实人做同事的时候关系一直不错，一起出过差帮他做项目，觉得老实人虽然能力差点，但心思单纯，而且老实人家里只有他一个人工作，上有老下有小，养家不容易，所以在工作上时常帮他补坑，被评为除了前领导最护着他的人之一。即使是现在面对他板上钉钉要被辞退的现实，我也时不时心软，觉得他在改了在改了，还有变好的可能，但是一想到老实人在我手下的种种表现，以及再续签就是无固定期限合同的未来，就觉得还是算了。\n被通知调来我组的老实人，春节前几天慢悠悠地收拾了东西，其中搬工位就耗费了他一天的精力。好不容易等其驾到，刚要给他安排工作，老实人表示自己要早几天回去，用的依然是通知的语气。我刚升主管不久，本身自己也请了年假，又兼对方比我年纪大又是以前同事，觉得只是他不善言辞，全然没放在心上，谁知这根本不是无心，而是试探我态度的开始罢了。\n因为自己已经请了年假回家，暂时拜托同事X（职级比我高），也是老实人的老同事，给老实人安排年前的工作，不到半天，告状的电话就打过来:“我安排他组装一下新到的椅子，他居然说，这也要我做？！”由于X之前就很看不上老实人，我赶忙安慰X老实人无心之失不会说话，又赶紧给老实人打电话问明情况，结果老实人张嘴第一句仍然就是“这也要我装？”护老实人的我选择循循善诱，直到老实人说“哦，对，我们以前在前领导那有时候也自己装”，然后又交代了几句说话注意语气，别惹X生气，算是平息了这场风波。\n现在从这件事情来看，我是真的挺护着他，也怪不得后面X吐槽:“你是我们之中最护着他的……”\n依然”不善言辞”，对礼貌没有基本常识的老实人。春节后，大家陆陆续续回来了，我详细的规划了工作，只等着老实人年假结束回来就交给他，我一直觉得老实人只是能力差些，但踏实肯干，总能教会。但是接下来老实人开始了他骚操作式的请假。\n因为老婆做手术，老实人在他的假期马上到的前一天，通知我他要请假，语气是“XXX，我老婆做手术，我要请3天假，我已经和F总（部门老大）打过招呼了”，包子如我，不仅没有批评他，反而关心了他老婆的病情。临到三天结束又是三天假，三天复三天地请着，一直请到月底，到了最后连招呼都不打了，直接钉钉上递交了请假申请。我连忙问F总是否知道他要请假，得到的答案是否，F总直接亲自下场敲打了他一顿。老实人仿佛突然懂得了礼貌，连忙和我道歉上表示下次不会再这样了。\n老实人并不是不善交际不懂礼貌，只是你不值得他懂礼貌而已。而看着老实人可怜巴巴道歉的样子，此刻我居然又开始觉得他“只是不善言辞”，心理上一下又可怜起他来，反而觉得自己小题大做了。二月开始，老实人终于姗姗来迟恢复工作了，没想到这才是让我大跌眼镜的开始。\n摸鱼大师级人物的老实人2月，老实人总算正式来上班了，却让我大开眼界，意识到了什么叫摸鱼大师级人物。一开始只是让老实人询一下标准品，给了老实人几个销售的联系方式，告诉他可以问这些人直接要，于是，老实人兢兢业业询了一个礼拜才完成了其他人空余时间就能完成的工作。中间我曾问起，老实人表示某些符合要求的标准品非常难找，自己正在努力上网搜索寻找供应商，得，他倒干起采购的工作来了。到了周五，在我的催促下老实人终于把一个……excel交给了我，而他，作为一个老员工，在完全是清楚正常采购流程的情况下，甚至没有把这个表格交给采购！\n第二周，我让他写一些文件，模板已经给了他，而且以前他是写过相关文件的，于是他继续愉快地摸起了鱼，三天以后，交给了我其中的一篇，不夸张的说换我一下午就能写2份，在我忍不住发火之后，在周五交上了其余的6份文件。\n接下来让他负责某包装参数的优化，又是实验五分钟，等待两三天，“忙碌”了两周，最后给我的反馈是，怎样都会漏气的，最终不了了之。\n3月中旬，一切就位，终于能开始安排他做正经实验了，于是实验小半天之后又神秘消失，问就是在忙，一看，实验小半天，记录写两天。被我训了一次，立刻在2小时内写完。3月底，在我的各种指导下，老实人终于完成了他过去可能要一整年的工作量:解决他之前转产时的历史遗留问题，以及一个方法的验证，当然，问题其实是我解决的，他只负责操作，如果放任他自己做或者想下去，那必定又是一件不了了之，或者别人都无法复现的工作。因为老实人总会将问题的原因归结为某种玄学，比如，离心管在涡旋震荡仪槽上插入的高度严重影响了他的结果，又或是一大堆色谱柱里只有这一根才能复现他神秘的实验，建议我们买一大堆再里面挑一根再创奇迹。\n现在想起，老实人的摸鱼水平也依然让我惊叹，也琢磨不透，因为每次有空你望向他的工位，他永远没有在看手机，而是在电脑上浏览着相关网页。我到现在仍然不知道，他那询标准品的一整周是怎么将时光消磨干净的。\n与其责怪自己，不如指责他人？三月后半月，老实人在我的全程保姆式的安排催促和解决问题之下，终于有了一些能看的工作量，Q1绩效评分在F总那里也蒙混过关。我也终于摸到了对付老实人的方法:明确安排好老实人每一天要完成多少工作量，并且一定要设置明确的DDL，一旦布置类似于“你抽空把这些文件写一写，五月中旬要交”式的工作，那在老实人这里就等于没有布置。\n在这种设置下，整个四月老实人终于开始干起了活，当然，依然是保量不保质，兢兢业业地做出了一堆有问题的数据。过程中大错不犯小错不断，一直犯些新手的低级错误，而每次出错时，他都要将仪器和试剂从上到下怀疑个遍，而从不怀疑是自己的低级错误。以至于某次我无奈地说“承认自己配错了有那么难吗？”的时候，旁边的组员妹妹没忍住笑出了声。\n这让我想起两年前他验证我开发的方法时，因为自身溶液配制问题，和另一个溶液配制困难户（目前也已经在劝退边缘了）联手指责我“方法不好，东西不成线性”，最后隔壁其他项目组的成员一次成功，两人啪啪打脸的经历。时至今日，他依然在犯这样的错误，也依然不会反思自己的问题。老实人的口头禅依然是“这个当初是她做的，我不知道”或者“那这东西就这样，我有啥办法”，以及“那你没告诉过我，我怎么知道”，将与其责怪自己，不如指责他人的精神发挥的淋漓尽致。\n从10分提升至30分，还是不及格——老实人的东窗事发。当我还沉浸在老实人终于做出点东西，自己教导初见成效的时候，base长期在外地的F总出差回来，宣布除周报外，以后每月开一次组会做一页PPT总结一下本月个人工作。万万没想到，就是这一页PPT，成了开除老实人的导火索。\n因为F总让大家直接都把PPT提前一天交给他，于是我让组员都直接交给F总，不用再经手我这里（现在看看，如果当初经过我手，可能还会帮老实人改PPT，他可能甚至不会东窗事发），直到前一天晚上下班六点多，F总问我老实人的PPT怎么还没交，我通知后，老实人才急急忙忙做了PPT交上去。第二天组会，轮到老实人时，我惊恐地发现老实人连自己四月的工作都没写齐全，内容也可以用一句话概括:“我做了一个实验，然后失败了”。我不愧为最护老实人的人之一，此时依然在帮老实人挽尊，解释说实验设计上也有些问题，已经重新又从第0天开始考察了，要继续放置七天。此时，我之前提过的，装椅子事件里的同事，X博，开始了一连串的灵魂拷问。\n让老实人真正陷入宕机状态的问题是，你重新零天开始考察，到五一放假的时候只能做到第五天，你第七天的时候打算怎么办？老实人的心里根本没有节前反序放置7天，节后再补一个数据点的概念，只想着自己的票早已买好，“加班”两字可千万不能说出口，于是会场陷入了死一般的寂静。\n沉默了一会，组员妹妹提出了节前反序放置，这样又不用加班也不用中断实验，可惜这样对老实人来说“新奇”的想法让他本就宕机的大脑再次过载，众人七嘴八舌解释了几遍也没回过味来，领导让他回头慢慢想，会议才得以继续进行下去。\n当天下午三点，F总先是在VX上和我们吐槽“感觉老实人四月份什么也没做”，由于F总和我们一向打成一片，领导风格也是以轻松幽默为主，我本以为F总会要求批评老实人一顿，要求他再接再厉。结果去了他的办公室，F总却说老实人这么简单的实验都能犯错，叫我看看要不要把老实人开除了。\n我组本身就任务重难度高，我正处于极端缺人的状态，于是一直在为老实人解释:他没有放上全部的工作，有些零碎的工作他没有放;他也算0.5个战斗力，总比没有强;他家就一个他养家，年纪也大不容易。F总一一辩驳，并开玩笑说不用担心，到时候多招一个新员工换，谁不好就开除谁……啊，我想，比他还差的员工，可能在面试的时候就会被卡住，怕是也不好招到了。\n接着F总表示，既然做不好实验，就派他去和隔壁部门做些沟通交流写文件的工作，我和X博惊恐摇头，我表示他沟通能力极差根本不能胜任，而X博则从摸鱼的角度指出，这种没有明确节点又能捞功劳的事情绝不能让老实人做。但F总意愿坚决，要求老实人负责沟通交流的工作，表示他再看一个月，如果老实人仍然不改，就让老实人滚蛋。\n一次谈话让我彻底对老实人失望接到任务后，我立刻找到正在做实验的老实人，表示等他有空跟我单独聊一下。看到他忙于实验的样子，我暗感老实人最近已有所改观，仍然抱着一丝侥幸心理，说不定老实人被骂以后能痛定思痛，焕然一新。谁知接下来的谈话却让我大跌眼镜。\n对于工作量少，老实人解释他承认2/3月份做的少，但是这个月做的很多（事实上工作量和刚来半个月的新员工差不多），并且细数起了自己的零碎工作，最后竟然问我“你没和F总说吗？”，被我回怼之后，又解释说自己太过忙于实验，没时间做那一页PPT。\n对于会上X博的灵魂拷问，我问他本来打算怎么办？“我本来觉得这次实验也会失败，所以我先做几天看看。”“万一成功了呢？”“万一成功我就先拿5天的数据，然后节后再来重头做起。”我还是第一次见祈祷自己实验失败的实验人，合着这位的小算盘打的都是实验失败。狠狠训斥了他一顿之后，老实人表示自己要加油努力提高工作量，下次再也不会了。\n临离开前，老实人又主动聊起了PPT，并且抱怨自己没收到通知。我拿起微信里的聊天记录，当场指给他看自己两天前发布的通知。谁知老实人见状，又说了一句令人吐血的话:“你只说要做，没说要交给F总。”（交给F总我是口头在办公室通知了所有组员）我说你不交给F总，交给我也行啊？你没谁也没交啊？最后我追问他什么时间开始做的PPT，老实人表示:“昨天晚上你说我没交PPT以后。”原来并不是老实人早早做完老实到不知道交，而是老实人根本就没做。\n一番令人无语凝噎的对话将我对老实人本来充沛的同情心消磨殆尽，我将谈话记录原原本本告知了F总和X博，心里也从一开始“还有变好的可能”转向了F总的开除方案，在微信上和老实人布置了他的新工作（不然老实人会像PPT事件一样说你没说过），并且警告他如果到5月没有改善，就会面临开除风险。老实人微信回了一个“好的”就陷入了死寂。 \n老实人的传统艺能“你没说”和“我不会”第二天一早，我就给老实人开始布置各种活计，由于跨部门交流本身就琐碎事情多，且昨天刚刚接到做不好就开除的通知，老实人头一次破天荒地拿出了他的记录本，认真用笔写下了要做的事情。\n然而慢节奏的行事风格早已养成，改起来哪是一日之功？老实人忙碌了一早上，才完成了其他人2小时内就能完成的任务，甚至因为觉得他太慢，我让小助理又分担了他的一部分工作。饶是这样，老实人依然出现了漏交材料的情况。老实人刚上交去不久，对接部门的A总就打电话过来，一一询问起我问题来。其中某个漏交的资料一开始没找到，后面找到了，我通知了老实人让他经B部门交给A部门，最后老实人却没交。我一问，老实人立马冤枉搬地喊起来“你没说……”然后又想起自己的微信记录板上钉钉，把后半句生生咽下去，立刻站起来去对接B部门了。\n下午，同样的事情又发生了一遍，老实人忙碌了两个小时，只交上来一份清单给我:一个5行，三列的excel。甚至在这15格内容里，依然还写错了一个数字。我问另一份清单在哪里，老实人依然稳定发挥了他的传统艺能“你没说！”我也依然一招制敌，拿出了聊天记录。然而老实人又开始了第二招“我不会，模板在哪里。”说实话，这两个文件在老实人躺赢在重要项目的时代里都经过他手，而此刻他的硬盘里就躺着他亲手写过的资料和模板。被我指出后，老实人一言不发地在他的电脑里找到了模板写了起来。\n到了晚上我去查看老实人的实验数据，发现他早上兢兢业业处理了1个小时的数据又出现了处理错误，接到电话的老实人急急忙忙赶过来，并且依然稳定发挥着不认账的传统，直到旁边的组员妹妹说“是有问题，我们都看见了”。老实人一边叹气重新处理，一边抱怨他今天一天“真是忙死了”，这忙死他的一天工作基本上也就是我半天的工作量，我只笑笑“现在你体会到我的工作了吧”。\n老实人眼神此时黯淡了起来，说起自己接到昨天的通知是多么害怕，此刻我该死的同情心又一次开始运转，安慰他好好努力完成任务，说不定领导就不生气了。\n","categories":["工作"],"tags":["职场","老实人","辞退"]},{"title":"第三波（序与前言）","url":"/2023/05/03/%E7%AC%AC%E4%B8%89%E6%B3%A2%EF%BC%88%E5%BA%8F%E4%B8%8E%E5%89%8D%E8%A8%80%EF%BC%89/","content":"总序\r\n纵览古今，人类诸文明创发演进，蜿蜒曲折，穿越时空，而能延续至今，均因它们能在发皇延续的历史进程中，容内百川，汲取不同文明的要素，将自身汇合成浩荡的巨流。\r\n不必讳言，近代西方文明所以后来居上，盖因蕴含在其典章制度、法政架构其后的学说义理，有足多者。百年以前，中国思想界的先贤已然认识到，处于列国环伺竞争的现代世界，既不能仅以“船坚炮利”为能事已毕，亦不能依旧空腹高心侈言心性，它意味着学术的重点要移至与“公共”相关的理论与制度的汲取与建构上来。张之洞尝言“西学之中，西政最要”；梁启超亦主“译书以政学为先”。近代以来，有识之士，窃火异域，汲汲以译书为先务，对推动中国社会的近代转型起到了难以估量的作用。\r\n百年如昨，前贤曾为此殚思竭虑，亟待后人承其遗绪。此处的“公共”一语，西文源自拉丁语ResPublica，其本义为公共事务，引申为“共和”之义。随在市场经济在当代中国的复苏与拓展，公共领域与私人领域由是分化，“公共”的制度重构已成当务之急。私域是个人合理为己之域，个体自由的理念开放了个人利益寻求和价值偏好的多样性；公共领域则是向天下开放的公共权力之域，亦为政治正义寄身之所。以个人自由为价值内核，以宪政民主为制度中坚，正是所谓“公共”的鹄的之所在。职是之故，我们继“公共论丛”之后，又有“公共译丛”的创设，旨在通过有关著作的移译，获取相应的思想资源，意欲致力于打开理论的户牖，让既有的思想庋藏八面来风。\r\n瞑色四合，二十世纪行将降下自己的帷幕；放眼未来，古老的中国文明将在新的世纪里，祛除旧染，重后新机，汇入人类文明的主流。兹事体大，固然不能不度德量力；积土成山，我们愿为此竭尽绵薄。\r\n译丛以“公共”为名，不仅指称丛书的旨趣，同时也意味着，“公共”之学术乃天下之公器，诚望海内外学人，无分彼此，鼎力相助。\r\n《公共译丛》编委会 1998年5月于北京\r\n\r\n序 第三波：二十年之后看未来\r\n亨廷顿\r\n约在五百年前，有一小群葡萄牙的政治领袖和思想家，其中包括国王约翰二世、航海家亨利王子、巴特罗缪·迪亚士和巴斯克·达·伽玛，他们以自己的勇气、果敢和想象力，用自己的行动开创了人类历史的一个新时代，即地理大发现的时代。他们树立了一个良好的典范，于是，西班牙、法兰西、不列颠和尼德兰起而效仿。约在20多年前，马里奥·苏亚雷斯和他的同事们以同样的勇气、果敢和想象力，用行动开辟了人类历史的新阶段，即民主的时代。他们也树立了一个良好的典范，于是，西班牙、希腊、巴西和许多其他国家群相仿效。\r\n然而，这一结果却不是命中注定的。1974年4月，在军人推翻了独裁政权之后的好几个月里，葡萄牙充斥着混乱和冲突，在那个时候，民主的前景似乎十分黯淡。许多人都以为，葡萄牙的斯大林主义式的共产党可能会掌权。甚至连美国国务卿基辛格也持这一悲观态度。当马里奥·苏亚雷斯这位当时的临时政府的外交部长拜访基辛格时，基辛格批评他和他的政府未对共产党人采取一条更强硬的路线。\r\n基辛格说：“你是一位克伦斯基，我相信你的真诚，但是你太天真了。”\r\n苏亚雷斯答道：“我当然不要作克伦斯基。”\r\n基辛格回了一句：“克伦斯基也不想。”\r\n不过，马里奥·苏亚雷斯和他的同事们证明基辛格错了。在葡萄牙克伦斯基们赢了，民主得到了巩固。马里奥·苏亚雷斯担任了总理，后来，又当上了总统。葡萄牙所开启的第三波民主化浪潮创造了一个民主的时代。在这一次浪潮中，人类历史上来行某种民主政体的国家总数在世界上第一次占到了一半以上。\r\n让我们简单地考察一下这项记录。首先，始于十九世纪初的民主化长波到1920年为止，导致了民主在约30个国家取得了胜利。在本世纪20年代和30年代，由于威权主义的复辟和法西斯主义的兴起，到1942年止，世界上的民主国家的数量降到了约12个。第二，第二次世界大战后的民主化短波再次使世界的民主国家的数量增加到30个以上。在此之后，在这些国家中，又有许多民主政权垮台。始于葡萄牙的第三波民主化浪潮中民主化的速度更快，在规模上也远远超过了前两波。20年前，世界上约有不足30％的国家是民主国家，现在，60％多的国家是通过某种形式的公开、公平和竞争性的选举来建立政府的。约在25年以前，威权政府（共产党的政治局、军人政变集团、个人独裁政权）似乎蔚然成风，今天，千百万以前曾在独裁专制统治者下受苦受难的人生活在自由之中。此外，由于历史上民主国家与民主国家之间不发生战争，和平地带也得到了大大地扩展，国家间冲突的可能性也大大地降低。民主制度在如此短的时间内急速成长，毫无疑问，是人类历史上最壮观的、也是最重要的政治变迁。\r\n但是，未来如何呢？那些新兴的民主国家的民主体制将会得到巩固吗？会有更多的国家变成民主国家吗？我们有可能看到一个民主不仅是主流政体，而且是普遍政体的世界吗？\r\n选举与民主\r\n这个问题涉及到民主对不同文化的民族的不同的含义。自第二次世界大战以后，主流的方法几乎完全根据选举来界定民主。民主被看成是构建权威并使其负责的一种手段。在其他政治体制中，人们通过出身、任命、考试、财富或强制成为统治者。相比之下，在民主制度中，要么像在直接民主中那样，人民既是统治者又是被统治者，要么统治者由被统治者选举产生。一个现代民族国家，如果其最强有力的决策者中多数是通过公平、诚实、定期的选举产生的，而且在这样的选举中候选人可以自由地竞争选票，并且实际上每个成年公民都有投票权，那么，这个国家就有了民主政体，这一民主的程序性定义是由熊彼特在《资本主义、社会主义与民主》一书中提出的，并得到了普遍地承认，也得到了在这一领域从事研究的学者的公认。\r\n根据这一定义，选举是民主的本质。从这一本质中产生了民主制度的其他特征，只有存在着某种程度的言论自由、集会自由、新闻自由，只有反对派候选人和政党能够批评现任的统治者而不害怕受到报复，才有可能进行自由、公平和竞争性的选举。\r\n不过，选举是民主的全部吗？去年（1995年），拉里·戴蒙德在其刊登在《民主杂志》中的一篇观点鲜明的文章中详细说明了自由民主与选举民主的分野。自由民主国家不仅仅举行选举，而且还对行政权加以限制，还通过司法独立来坚守法治，还保护个人的表达、结社、信仰和参与方面的权利和自由，还尊重少数一方的权利，还为执政党制定对自己有利的选举程序的能力加以限制，还对任意地逮捕和滥施暴力加以有效地防范，还不实行新闻审查，并把政府对媒体的控制降至最低限度。在实行选举民主的国家，政府也许是通过相当自由和公平的选举产生的，但是它们缺少那些在自由民主国家存在的保护权利和自由的许多制度，如同拉里·戴蒙德所指出的，实行选举民主国家的数量在最近若干年有很大的增加，但是自由民主国家的数目却相对原封未动。根据最新的一项调查，有118个国家够得上是选举民主国家，然而，只有其中的79个国家被归入“自由”一类，即自由民主国家。约有39个通过选举产生政府的国家被判为部分自由的国家，其中包括俄罗斯、印度、乌克兰、土尔其、巴西、巴基斯坦和哥伦比亚。\r\n由于这一区分，一些人已经开始怀疑在民主与选举之间划等号的做法。他们开始谈论“选举主义的谬误”和“自由选举的陷阱”。一位杰出的美国学者甚至已经指出，在一个民主国家选举也许是多余的：如果人们有抗议、批评。纠织、示威和游说其统治者的自由，选举将是不必要的。\r\n另一位批评者认为，对一个处于民主化进程中的社会来说，有新闻自由比自由选举更重要。当然，说这话的是位记音对选举的这种失望有多方面的原因。但主要是因为非西方国家的选举结果不同于西方社会的选举结果。\r\n首先，在非西方社会，选举可能会导致那些严重威胁到民主的政治领袖和政治团体的胜利。在拉美国家和前苏维埃加盟共和国，由选举产生的行政首脑常常以专断的和不民主的方式行事，压制其对手，靠法令来统治，格鲁吉亚的加姆萨胡尔迪阿是一个先例，秘鲁的藤森是个近例。在拉美，由选举产生的其他行政首脑常常无视立法机关，并通过宪法修正案，强行延长其任期。在缺少西方自由传统的非西方社会，由选举产生的政府常常对个人的权利漠不关心，歧视少数民族，扼制新闻自由，甚至鼓励警察滥施暴力。\r\n其次，在非西方国家的选举，常常诱使政治家去提出那些最能为他们带来选票的诉求，而这些诉求往往带有种族主义、宗教教义和民族主义的色彩。这些诉求会加剧国家的分裂，并导致反西方的政治领袖和政策的胜利。荒谬的是，采行西方民主制度的非西方社会常常鼓励排外主义的和反西方的政治运动，并允许它们获得权力。民主成了一种地方化的、而非世界化的过程。在非西方社会中的政治家们不是通过表明他们是如何西化来赢得选举的，那些挑战西方世俗主义的、有宗教倾向的政党在土耳其、印度、以色列和前南斯拉夫共和国的选举中取得了胜利。阿尔及利亚的军人政府废除了一次选举，在这次选举中，信奉原教旨主义的伊斯兰救国主义阵线势在必胜。土耳其的军方迫使由伊斯兰福利党领导的政府下台。在一些穆斯林国家，人们只能在反民主的世俗主义与反西方的民主之间作出选择。\r\n在西方，选举民主建立在并产生于自由主义的政治传统之上，这一传统的核心是人权和法治。不过，选举民主在不自由的、非西方的政治体制中也许会扮演某种角色。请看看伊朗的例子。这是一个原教旨主义国家，最高的权力在最高的阿亚图拉和由宗教领袖组成的卫道会（the\r\nCouncil of\r\nGuardians）手中。对革命、对政权及其宗教领袖的批评都受到了严厉的压制。新闻媒介要么由政府控制，要么受到无情地审查。宗教上的少数派不断受到骚扰。其中如巴哈教派（the\r\nBahai）甚至受到迫害。据报道，任意的逮捕经常发生，对囚犯的虐待司空见惯，肢裂是一种刑罚。在那里有大量的政治犯。很显然，伊朗是一个远离西方自由传统的国家，然而，在某些方面，伊朗又实行选举民主。在1997年的总统竞选中，哈塔米取得了对体制内候选人的压倒性的胜利，赢得了69％的选票。而在这次选举中，有88％的成年选民投了票。在1993年，拉夫桑贾尼在还有另外三位候选人参加的竞争白热化的选举中赢得了63％的选票。在1992年的议会（the\r\nMa－\r\njlis）选举中，卫道会否决了一千多位当选心切的候选人的参选资格，但是，还有剩下的二千多人轰轰烈烈地相互竞争270个席位。在1996年，卫道会否决了二千名议会候选人的资格，但是还剩下3000人竞争270个席位。尽管政党被禁止，这两次中的候选人都是两个半政党团体的成员，一个代表较为温和的观点，另一个代表更为原教旨主义的观点。妇女既可以投票，也可以竞选公职，并在1997年占据了议会5％的席位。此外，议会有很大的权力，它拒绝过总统对内阁职位的提名，它偶尔也迫使内阁部长辞职，它还就经济政策和其他问题进行激烈的辩论。在1994年和1995年，它还成功地阻止了当时的总统拉夫桑贾尼试图通过的许多改革措施。可以说，伊朗议会是中东仅次于以色列议会的最活跃的议会。在伊朗选举竞争的激烈程度也高于任何一个阿拉伯国家和除一二个之外的所有的穆斯林国家。这样，伊朗就把竞争性的选举、制衡与原教旨主义镇压政策和大规模地侵犯个人权利结合起来。在波斯湾，沙特阿拉伯作为美国最亲密的盟友，是最不民主的国家，而伊朗作为美国最大的对手，却是最民主的国家。\r\n西方的民主\r\n植根在个人自由、个人尊严思想中的自由民主是一个西方的产物。有人认为，自由民主在西方之外的地方行不通，不过，事实上，在几乎每一种其他文明中，都有一个自由民主国家存在。简而言之，自由民主并非内在地与其他主要的非西方文化不相容，然而，非西方社会接受无论是自由民主还是选举民主的程度因他们受西方的影响程度不同而异。约有39个国家，其政府是由相对公开、公平的选举产生的，但仍然缺乏全面的政治自由和公民权利。其中，10个在拉美，8个在非洲，5个是政教国家，5个是穆斯林国家。在这些国家，选举民主未必是通向自由民主大路上的一步。再看另外三个例子：印度、土耳其、斯里兰卡。这三个国家成为选举民主国家几乎已近半个世纪，但是，它们在保护其公民的权利和自由方面仍然乏善可陈。\r\n世界上的各大文明在其文化与西方的接近程度和受西方影响程度上都有很大的不同。按照一些人的看法，拉丁美洲显然是西方的近亲，有人甚至认为，应被看作是西方家族中的一个成员。东正教则是一个更为执傲的远亲。在非洲，西方的统治极其短暂，其影响除在南非外，相当有限。西方对穆斯林国家的影响程度也因地而异，但在伊斯兰的阿拉伯心脏地带，也很有限。有关中国的情况也是如此。总体上，证据表明，非西方社会对不论是选举民主还是自由民主的接受程度因这些社会直接受到西方影响的程度而异。\r\n当政治领袖们相信，他们的利益在于推进民主，或他们有义务实现民主时，民主的发展就会出现。这样的精英在世界上的许多地方都不存在。在多数穆斯林国家，威权统治者掌控一切，没有表现出任何迹象表明要实行向民主开放。在穆斯林世界中，少数几个民主国家，统治者也常常用不民主的方式进行统治。对实现从选举民主向自由民主的转变聊无兴趣。甚至更重要的是，几乎所有的穆斯林国家都不是由原教旨主义统治的，但是原教旨主义运动支配、甚至操纵着反对现政权的力量。信奉自由民主的反对派团体几乎不存在。阿贾米观察到，“在每一个穆斯林社会，要写一写自由主义和全国性的资产阶级传统，无疑是在为这样的一群人写悼词，这些人打的赌，毫无取胜的希望，随之就输掉了。”此外，人们普遍承认，民主依赖于一个壮大的市民社会。在穆斯林社会，的确有壮大的市民社会出现，但是这是一个原教旨主义的市民社会，而不是一个世俗的。自由主义的市民社会。\r\n许多东亚社会的精英不习惯自由民主。的确一些西方学者认为，亚洲是“不自由的民主”（illiberal\r\ndemocracy）的老家。这种民主是一种文化传统的产物，这种传统强调国家的养民与教民的作用，并以此作为公民行为的准则，而不是作为个人权利的保护者。\r\n限制国家的人权观念在东亚极其薄弱。就个人权利受到承认的程度而言，这些权利通常被看成是由国家创设的权利。对和谐与合作的强调优先于分歧与竞争。对秩序的维持和对等级结构的尊重被看作是核心的价值。观念之间、群体之间和政党之间的冲突被看成是危险的。因此，就其在亚洲社会发育程度而言，选举民主更可能被设计用来产生共识，而不是选择，很可能具有不同于西方选举民主的特征，可能\r\n缺少伴随着西方民主的自由实践和制度的阴暗面。\r\n无论如何在第三波之后二十年的今天，民主化的条件远比以前有利得多。西方自由民主国家的各国政府在促进全球的民主化方面都可以有更大的作为。共产国际（the\r\nComintern）已经寿终正寝，现在该是建立民主国际（the\r\nDemintern）的时候了。\r\n前言\r\n本书探讨的是二十世纪后期一项重要的，也许是最重要的全球性政治发展：即大约有30个国家由非民主政治体制过渡到民主政治体制。这本书试图解释发生在1974－1990年间这一波民主化的原因、方式及其直接后果。\r\n本书横跨理论和历史两个领域，但是它既不是一部理论著作，也不是一部史书。它位于两者之间；它基本上是一部解释性的专著。一项好的理论不仅精确、严谨、优美，且能凸现出若干概念变项间的关系。然而没有一项理论能够全面地解释一个单一的事件，或一组事件。相比之下，一项解释则难免庞杂、肤浅、拖泥带水，而且思想上不令人满意。一部解释性的专著，其成功的秘诀不在于严谨，而在于全面。一部好的历史书则按照编年史来描述，并令人信服地在分析一系列事件的同时表明为什么一起事件导致另一起事件。这项研究也不作那样的工作。它不去详细刻画在七十——八十年代间民主化的一般过程，也不去描述个别国家的民主化情况。相反，它试图解释并分析一组特定的国家在一段特定时间内的过渡情况。用社会学的术语说，这项研究既非是通则性的，也非是细则性的。理论家和史学家都很可能因此发现这本书不令人满意，因为它既没有提供前者所青睐的概括，也没有提供后初所偏爱的深刻。\r\n因此，在研究方法上，这项研究完全不同于我的前几部著作。在其他那些著作中，我试图发展出一套关于关键变项间关系的概括和理论，诸如政治权力与军事职业制，政治参与与政治制度化、政治思想与政治行为，这些关于它们间关系的命题通常是作为超越时间界限的真理提出来的。不过，在这本书中，我的概括仅限于发生在七十年代和八十年代间的一组不连续的事件。的确，本书的一个重点是要说明第三波民主化与前两波民主化的差异。在撰写这本书时，我禁不住地想要提出一些超越时间界限的深刻真理，诸如，“置换比变革更充满暴力”。可是当时我又不得不提醒自己，我的证据只来自于我所研究的有限的历史事件，而且我在撰写的是一部解释性的、而非理论性的著作。所以我必须彻底放弃没有时间界限的现在时态，而用过去时态来描述：“置换在当时比变革更充满暴力”。除在极少数的几个例外的情况下，我都是这样作的。在某些场合，命题的普遍性似乎如此明晰，以至我禁不住地要用更没有时间界限的词汇来陈述。此外几乎没有一项命题能够适用于第三波的所有情况。因此，读者们会发现，像“趋向于”、“通常”、“几乎总是”这样的词和其他一些这样的修饰词经常出现在通篇的正文之中。根据我最终采行的表达方式，上面所有的命题应该读成，“当时，置换通常比变迁更充满暴力”。\r\n这本书写于1989年和1990年间，当时我所关心的那些事件还在发展。因此，这本书碰到了同时发生性（Contemporaneity）带来的所有问题，故本书必须被当作对这些政权过渡的一个初步性评估和解释。本书引证了历史学家、政治学家和其他学者的著作，他们就特定的专题撰写了详细的专论。本书还在很大程度上依赖于对这些事件的新闻报道。只有在第三波民主化告一段落时，才有可能对这一现象作更全面、更令人满意的解释。\r\n我以前对政治变迁的研究，即《变迁中社会的政治秩序》（political Orderin\r\nChanging\r\nSocieties，简称《政治秩序》），把重点是放在政治稳定的问题上。我写那本书是因为我认为政治秩序是一件好事。我的目的是要发展一项通则性的社会科学理论来解释能否实现稳定的原因、方式和条件。现在这本书的重点是放在民主化上。我写这本书是因为我相信民主自身是一件好东西。而且就像我在第一章中所表明的那样，它对个人的自由、国内的稳定、国际的和平和美国有正面的后果。正如同在《政治秩序》（Political\r\nOrder）一书中一样，我试图使我的分析尽可能地独立于我的价值观；至少在本书的50%的篇幅上是如此。不过，对我来说，偶尔地明确地表明我的分析对那些希望在其社会中实现民主化的人士所具有的意义也是十分有用的。因此，在本书中有五处，我放弃了社会科学家的角色，而担当了政治顾问的角色，提出了若干条“民主派准则”。如果这使我像一个胸怀大志的民主马基雅维利，那还是随它去吧。\r\n导致我撰写这部书的直接促成因素是1989年11月我被邀请去俄克拉荷玛大学作朱利安·罗斯鲍姆讲座（JulianJ．Rothbaum\r\nLectures）。在这些讲座中，我提出了本书的主要论题，当然那时还没有经验证据来支持这些论题。该书的大部分手稿写成于1989年底和1990年，而且我没有试图在我的分析中纳入发生在1990年之后的任何一起事件。我非常感谢俄克拉荷玛大学卡尔·阿尔伯特国会研究中心及其主任罗纳德·彼得斯博士（Dr．Ronald\r\nPeters）邀请我前去作这些讲座。我的妻子南希和我想要在此表明，我们非常感谢我们在俄克拉荷玛大学受到彼得斯博士和朱利安·伊莲娜·罗斯鲍姆和乔尔·扬克夫斯基以及众议院议长卡尔·阿尔伯特夫妇对我们俩始终如一的礼遇和款待。\r\n尽管讲座邀请促成了我撰写这部书，但是书中的材料却在我心中酝酿了一段时间。在手稿中有好几处我是取自于以前的两篇文章：“会有更多的国家实现民主吗？”（Will\r\nMore Countries Become Democracy）（《政治学季刊》［Political Science\r\nQuarterly，1984］，第191-218页）和“民主的适中含义”（The Modest Meaning\r\nof\r\nDemocracy）载于《美洲的民主：停止摇摆》（D．罗伯特·帕斯特编，纽约，1989年，第11-28页）。在1987年到1990年间，约翰·奥林民主与发展研究员职位（John\r\nMolin Fellowship in Democracy and\r\nDevelopment）使我得以花更多的时间和努力来研究这本书的主题。\r\n许多人有意无意地对这部手稿作出了很大的贡献。自1983年以来我一直在哈佛大学基础课程中教授现代民主，这门课重点谈的是民主过渡问题。学生和助教们都会发现，本书中的许多材料是来自于这门课；我对这个问题的一些想法由于他们的评论和批评而得到了很大的改进。玛丽·基拉里（Mary\r\nKiraly）、李永珠（Young Jo Lee）、凯文 ·马基奥罗（Kevin\r\nMarchioro）和亚当·波森（Adam\r\nPosen）在推敲书中的材料和整理我在这一课题上的文献时提供了必不可少的帮助。杰夫里·辛巴罗（Jeffrey\r\nCim-balo）不仅完成了这些任务，而且还在这部手稿的最后准备阶段特别认真地校阅了正义和脚注。朱丽安·布莱克特（Juliet\r\nBlackett）和艾米·英格尔哈特（Amy\r\nEnglehardt）把他们非常卓越的文字处理技术运用于这份手稿上，有效、迅速而且准确地打印出了许多草稿，和对草稿所作的似乎是永无止境的修订。我的几位同事阅读了我的这部手稿的部分或全部。侯昌·且哈比（Houchang\r\nChehabi）、爱德文·考尔（Edwin Corr）、乔治·多明格斯（Jorge\r\nDomiguez）、弗朗西斯·哈格比安（Francis Hagopian）。埃里克·诺丁格（Eric\r\nNordlinger）和托尼·史密斯（Tony\r\nSmith），提供了富有思想的、而且很有批判性和建设性的书面评论。哈佛大学比较政治讨论组的几位成员也通过活泼的讨论对我的手稿的前半部提出了很多意见。\r\n我非常感激他们对我的工作抱有兴趣，也感激他们对改进我这部书的品质所作出的贡献。不过，最后要说明的是，本书中的论点、论据和错误均由我来负责。\r\n塞谬尔·亨廷顿 麻萨诸塞州 坎布里奇\r\n1991年2月\r\n","categories":["book"],"tags":["democracy","politics"]},{"title":"辞退职场“老实人”（下）","url":"/2023/05/03/%E8%BE%9E%E9%80%80%E8%81%8C%E5%9C%BA%E2%80%9C%E8%80%81%E5%AE%9E%E4%BA%BA%E2%80%9D%EF%BC%88%E4%B8%8B%EF%BC%89/","content":"老实人的天降刀子\r\n是夜，F总和我们分享了一段他和A总的对话。原来A总觉得交接工作变成老实人负责很是诧异，问起来才得知F总要开掉老实人。结果得知此事的A总高兴地要请F总吃饭！\r\n原来老实人在前领导那里时，经常藉由前领导对其的偏爱推掉本该属于他自己的工作。一次A总希望老实人查查文献，协助写一下市场报告，最后老实人交上的报告却一塌糊涂不成样子。A总找到前领导，谁知却被前领导臭骂一顿，说他给的工作指令不明，根本不该柔弱无助的老实人承担。最后该报告也不了了之。\r\nX博听闻，表示之前和老实人打过交道的各路中高层，都不太看得上老实人，F总此时才感受到了前领导的护宝威力，知道当时被硬塞了一个怎样的人。而F总也从之前“如果不改就开除”的思想变成了坚决开除。思路也从帮助他改进变成了怎么收集证据证明他不胜任了。\r\n结果，第二天一早，还没等我制定PIP，我就发现钉钉系统上推送了一个通知。是老实人的劳动合同续签的提醒。细细一研究，发现老实人的合同竟然5月31号就到期了！而且在这里深耕多年的老实人，竟已经续签过两次合同，下次再签就是无固定期限的劳动合同了。F总当机立断拒绝了续签，表示老实人的工作态度还需要考察。而本来可能谨慎推进，收集证据的计划，也因为这个契机加速了起来，F总直接上报了大老板有意开除老实人，没想到这件事却被大老板树立成了正面典型，顺便又踩了一脚前领导，告诉大家上梁不正下梁歪，老实人刚去新部门三个月就被认为不合格，让大家引以为戒。\r\n公正的说，前领导确实是个好人，但不是一个好领导。在他的部门里，我们非常闲，甚至有位新员工没过试用期就主动离职，因为太闲了她怕待废。当时的我并没有选择像老实人一样躲在他背后拒绝工作，而是主动承担了很多任务，开发了好几个有挑战性的方法，但每个工作做完之后却都没有下文，不了了之。如果不是把我们拨给了F总，可能我也会在这样的温水环境里慢慢沉沦，最后变成一只被煮死的青蛙吧。\r\n“不上了”\r\n从得知老实人可能被开到棺材上的钉子一颗一颗钉死的过程中，睡眠质量极其优秀的我开始日日失眠。\r\n毕竟真要开除昔日一起共事的同事，还是家庭情况困难的同事，我根本下不了这个决心，特别是每次批评他时那一脸无辜的表情，被吓到般身体僵住和默不吭声的样子，都显得我像电视剧里职场霸凌的无良主管，而他则是那黑暗不堪的职场里唯一一朵盛开的小白花。只不过这位老哥的颜值属实无法带入想象，不然苦情电视剧的主角应有他的一席之地。但这也常常能给我致命一击，令我在同情和生气的两种感情中反复横跳，陷入失眠的状态。\r\n第二日一早，我顶着只睡了4个小时的状态上了班，却没发现老实人的身影，打开钉钉，发现老实人没打卡。虽然我们是不定时工作制，不用按时打卡，但老实人别的不说，从不迟到早退，极其遵守公司制度。由于在实验室和办公室都没发现老实人，我赶紧私聊老实人，叫他补上打卡记录，不然一天班白上。谁知却得到一句回复:“不上了。”\r\n我心下愕然，以为老实人已经得知自己要被开除的消息，破罐破摔，一时间脑子里已经转了800个弯，不知从何说起，最终却只说出这样一句话“那你把该退的群都退了吧”，心里五味杂陈，面上却强装镇定依旧做实验，结果过了一会老实人急匆匆跑来，“你说退群是啥意思啊？”我反问，“你不是说你不上班了吗？”“哎？我说的是补上了啊”我再一次拿出聊天记录给他看，他看了看，连忙哭笑不得地解释说他打错了，是补上了补上了。实验室的其他同事也开始调笑，说你怎么这么果断就开始打算接受他辞职了，不是应该先打电话问问吗？我假装跟着哈哈大笑，心里却更加苦涩，不久的将来，老实人真有一天要面对这件事情，届时他能接受吗？\r\n对别部门唯唯诺诺，对本部门能拖就拖\r\n自从将对接沟通的事情交给老实人后，我将精力集中到内部实验管理上。实验也接连取得突破性进展，就是最近大家的问题比较多，我打算开展一次系统性的研发培训，算算时间，上午大家应该都有空，于是在群里问了大家。大家很快回复都有空，唯有老实人表示自己要对接一上午，下午才可以。\r\n我心知老实人下午还有个耗时很长的实验，自己的培训却至少要讲两个小时，若是下午讲老实人必定要加班，何况对接的工作我自己一直在做，知道大部分时间都在打字对话沟通，改文件和写文件上，是随时能够按暂停键的工作。\r\n想到老实人之前磨洋工的“珠玉在前”，有点生气，于是追问他有什么工作要对接一上午？回答果然没让我“失望”，是两件鸡毛蒜皮的小事，而且甚至还有一件明显是其他部门责任范围的事情，大概每件事情5分钟内就能做到。老实人反说“可能还有其他的事情，自己要给他们留够一上午进行充分的对接。”我属实无语，他宁愿为其他部门“可能的事情”预留一上午，也不能为本部门的培训抽出两小时。再次问他最早早上几点能结束，得到的答案是十一点。最后我终于不客气地骂他5分钟就能搞定的事情要磨两个小时，并且直接下了最后通牒，十点开始培训。\r\n十点，老实人按时参加了培训，期间也没有看到他被紧急电话叫出去或者回复工作信息，一切风平浪静。看来他预想的对接事件并没有发生。我趁机也宣布了下午让助理组员和老实人跟一遍他的实验流程学习一下（是的，我已经开始布局交接问题了），老实人也一一应下。\r\n下午到了，助理组员一直等待着老实人过来，然而1个半小时过去了，老实人依然没来。“电话打了，他说他在忙着写文件。”眼看再不开始实验今天下午老实人必定要加班，还要连累助理和他一起加班，于是我一个电话打过去，告诉他文件晚点再写，先做实验再说。他则坚持把“其他部门催”的写完再过来。\r\n到了下班时间，对接部门的同事来了实验室找老实人，又开始了新的一轮拉扯，说他们领导提出过程太复杂，要删掉几个检测指标。对于这样敏感的无理要求，老实人居然一一应下，我眼见不妙，立刻出声制止，力陈指标的重要性，最终与对方商议后达成新共识，据此再度修改文件。只是老实人写文件的努力付诸东流，而且实验也连累助理加班到了晚上8点。\r\n被00后牵着鼻子走的80后\r\n假期前倒数第二天，老实人主动将他这一周的交接文件打包发给了我审核。由于当时早已下班，我答应他明天有空的时候复核。\r\n第二天下午，老实人问我要一份文件，据他称是“A部门要，上报集团的”。我手头并没有这份文件，而且如果要这份文件应该需要F总与合作方沟通才能取得，便让他直接联系F总。谁知过了一会F总便在群里怒气冲冲的问为什么老实人一个电话打给他要这份文件。我也诧异，不是A部门要的吗？于是赶紧联系A部门的A总，请问他对这份文件具体有什么需求。然而A总却回复:“谁让你交这份文件的？”\r\n在一头雾水的我打了一圈电话后，终于弄清了事情的原委:原来A部门的00后员工小L接到集团要求补充两个问题的说明，小L不知出于何意却向B部门同为00后的小G说自己要这份不好取得的文件（可能觉得文件里会有答案吧），小G表示自己没有，直接向老实人当起了伸手党。而老实人问也不问为什么，到处找起了文件。整个过程中，F总，我，小G的大小领导以及小L的大小领导通通不知情，完全是因为小L的突发奇想导演出来的一场大戏。\r\n弄清原委的F总阴阳了一句“现在的小朋友真有主见。”我则无奈的纠正，是“老朋友”和“小朋友们”。在整个事件中，80后的老实人被两个00后牵着鼻子走，虽说主要责任可不是他的，但是这种处理方式也着实不像一个35+的员工应该有的水平，但凡他多问一句小L，这件事情可能就不会发生，当然，我也有责任，听到了老实人的“A部门要，上报集团”就以为是A总要，未曾细究这个到底是A总还是A部门的某人。\r\n可谁知一波未平，一波又起，因此而牵出的第二件事才真正让我对老实人发火的原因。\r\n该谨慎时大胆，该大胆时谨慎\r\n好不容易解释清楚了这件事情，没过多久F总接着又给我发了一份文件过来，问我为什么这里和我之前发给他的不一样，而这个重要信息又被老实人填错了。我一看，这不是我之前发的一份，而是另一份文件，而这份文件是昨天老实人打包发给我的那堆文件里的一部分，我今天还没顾得上审核。F总冷冷的道:“这份文件可是我从A总手里拿到的，他看到有问题赶紧告诉了我。”\r\n我还没有审核的文件，为什么直接出现在了其他部门手里？他又有多少文件已经单方面和别人“敲定”，甚至已经盖章签字打印成型了？联想到A、B部门两位00后的行事风格，我心下一凉，赶紧叫住了刚刚回来的老实人。\r\n“你文件都已经交给他们了？”\r\n老实人一副理所当然的语气:“对呀，都交给他们了。”\r\n本来下定决心在最后的日子里不对老实人发火的我（上篇的事件我也没发火，只是明白原委后说责任主要不在你，劝老实人以后多问两句）终于没有忍住提高了音量:“我还没有复核你为什么要交给其他部门！”\r\n老实人仍然回以理所当然的语气:“他们催着我要啊，我就都给了。我们都敲定好了。”\r\n我忍不住怒吼:“他们催着你要你就给他们了？那你还让我复核干什么呢？你们都敲定了还给我复核什么呢？！”\r\n撂下一脸懵逼的老实人（他甚至还不知道自己做错了什么），我赶紧向F总汇报了这件事，并提出要我将交接工作收回，坚决再不能让老实人负责此事，而且这种私下敲定，隐瞒不报的行事风格绝不能留，应该坚决开除。F总大感无语，没想到平日做事畏首畏尾的老实人居然自己做了这么大的主，称老实人:“该大胆的时候谨慎，该谨慎的时候大胆。到底前领导是多么喜欢他，才给公司留了这么个神奇宝贝？”\r\n梦幻泡泡的破碎——与老实人的谈话\r\n也许F总从一开始将老实人调来负责他最不擅长的工作，就是为了制造更多的冲突，让我看清老实人扶不起的现实，并且引导我自己下定决心开除罢了。但是不管怎么说，我也感谢F总让我看清了这一切。我将老实人叫来，正式通知了他合同到期后不予续签的决定，让他下个月也不用做太多事情，自己准备好好找工作吧。\r\n老实人听后出乎意料的平静，表示自己早有预感。但仍然追问自己不续签的原因，是因为自己昨天要那份文件吗？是因为自己PPT没讲好吗？是因为前领导部门被拆分，已经有一个分去其他部门的员工被开除了所以自己也要被干掉吗？“是，但是它们都不是主要原因。”他絮絮叨叨将这几天他觉得有错的事情一一翻出，而我则帮他又分析了一遍。“那，只因为这个月没有做好，我就要被开除吗？”\r\n我深吸了一口气，问他一个问题:“你觉得你的能力，在我手下的员工手里，能排到第几？”我本以为老实人对自己的能力到底是应该有客观认知的，出乎我意料地，他竟然觉得他和我手下最优秀的组员妹妹（就是会上给了他方案的妹妹）能力上五五开！我笑道:“开会的时候你连人家告诉你的方案都听不懂，更别提自己想的到，而且这个妹妹只要简短的和她描述一下大致思路，她就能自发设计方案并且完成，你觉得你和她差不多？”\r\n老实人瞪大了眼睛:“方案是她自己写的？没有模板？”在得到了肯定的回答之后，老实人一时语塞，又很快环视了一圈实验室新添置的仪器，嘴里嘟囔着:“这些仪器我不会用，要是有人教我用我也能……”\r\n“你说这些我刚买的小仪器吗？这些仪器我买之前我也不会用啊，我们也都是对着说明书研究，操作指南还是大专生小助理写的呢，她可是专业不对口而且刚来实验室9个月而已。在我眼里，你的实验能力和小助理差不多，也就是你是研究生，文字和计算功底稍微比她强点。”老实人第一次发现我眼中的他竟然是这般评价，想要找出些证据反驳我，却发现似乎没有什么能证明他光辉历史的东西。我则就这个问题进一步攻击。\r\n“你和X博一直不睦，对吧？你知道她为什么这么针对你吗？”\r\n“我不知道……她确实有点……但……”\r\n“因为，她忍受不了蠢人。”\r\n而这个事实似乎也并不能让他相信，于是我使出了最后的杀手锏:“你知道当初把我和X博分给F总，但是没有分你，你知道前领导怎么说你的吗？”\r\n“他说，老实人能力也不行，实验也不太行，还是就在我这里吧。”\r\n","categories":["工作"],"tags":["职场","老实人","辞退"]}]