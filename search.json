[{"title":"恋人を射ち堕とした日","url":"/2023/05/03/main/","content":"二本目（にぼんめ）の記憶（きおく）弓（ゆみ）がしなり弾（はじ）けた焔（ほのお）夜空（よぞら）を凍（こお）らせて凛（りん）と青く別（わか）れの歌を恋人を射ち落とす（うちおとす）遠（とお）い日の忘れ物引（ひ）き咲かれた傷痕（きずあと）呪（のろ）われし約束をその胸（むね）に宿（やど）して「避（さ）けれれぬ終焉（しゅうえん）は、せめて愛（いと）しいその手（て）で」抗（あらが）えぬ衝動（しょうどう）の闇（やみ）が彼をつづんだ歪（ゆが）む世界    螺旋（らせん）の焔    輪回（りんね）を貫（つらぬ）いで凛と赤（あか）く血濡（ちぬ）れくちづけアナタを射ち落とす（忘レモノハ有（あ）リマセンカ？）｛古（いにしえ）の伝説（でんせつ）　その魔物傷を負わされた物は｝｛呪いが全身（ぜんしん）を駆（か）け周（まわ）り｝｛やがては同（おな）じ魔物に成（な）り果（は）てるだろう｝（その傷を負ったのはいつ・・・）｛それは二人が出会ったあの日まで遡（さかのぼ）る｝｛彼が彼女を助（たす）けた時に負った傷｝｛全ては出会った時から始まっていた｝（出会いは喪失（そうしつ）への約束）｛枯（か）れ果てた涙（なみだ）は｝｛悲（かな）しみの青い炎（ほのお）を宿（やど）し｝｛銀色（いろ）に輝（かがや）く矢（や）を放（はな）つ｝｛何度でも　ただ彼が息絶（いきた）えるまで｝愛する人を失（うしな）った世界にはどんな色の花が咲くのだろう？月を抱（いだ）いた十字（じゅうじ）の焔（ほのお）茨（いばら）を巻（ま）きつけて凛と白（しろ）く最後（さいご）の弓矢（アロー）私を射（う）ち落（お）とす\n","categories":["ANIME"],"tags":["歌词，恋人"]},{"title":"CSS基础","url":"/2023/05/03/CSS%E5%9F%BA%E7%A1%80/","content":"文字 fontfont-weight:bold;font-style:italic;font-variant:small-caps;font-size:lem;line-height:1.5em;font-family:verdana,sans-serif\n\n上述代码可以简写为\nfont:bold italic small-caps lem/1.5em verdana,sans-serif\n必须包括的属性值为font-size和font-family\n背景backgroundbackground-color:green;background-image:none;background-repeat:repeat;background-position:top;background-size:auto;background-clip:border-box;background-origin:border-box;\nbackground: color image repeat position\n边框线boder = border-color border-style  border-widthborder-radiusbox-shadowborder-image\n高度和宽度height width min-height min-width max-height max-width box-sizing\n内、外边距内边距 padding外边距 margin\n列表和表格list-style = list-style-type:Disc list-style-position:inside list-style-image:noneborder-collapses:collapseborder-spacing:10px 15pxtable-layout:auto\n位置和布局位置和布局的样式属性用于改变指定元素与其他元素的排列方式、显示方式等\ndisplay:block;visibility:hidden;float:left;clear:none;position:fixed;left,top,right,bottom:auto;cursor:auto;z-index:overflow:scroll;vertical-align:top;columns:auto1\n"},{"title":"matplotlib学习笔记","url":"/2023/05/03/matplotlib%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"InstallationMatplotlib releases are available as wheel packages for macOS, Windows and Linux on PyPI. Install it using pip:\npython -m pip install -U pippython -m pip install -U matplotlib\n\n\n  PS: Make sure you have installed the numpy\n\nuse pycharm to install directly\nA simple exampleMatplotlib graphs your data on Figures (i.e., windows, Jupyter widgets, etc.), each of which can contain one or more Axes (i.e., an area where points can be specified in terms of x-y coordinates, or theta-r in a polar plot, or x-y-z in a 3D plot, etc.). The simplest way of creating a figure with an axes is using pyplot.subplots. We can then use Axes.plot to draw some data on the axes:\nfig, ax = plt.subplots()ax.plot([1, 2, 3, 4], [1, 4, 2, 3])plt.show()\nParts of a FigureCustom PlotCustom function may be like as:\ndef my_plotter(ax, data1, data2, param_dict):    \"\"\"    A helper function to make a graph    Parameters    ----------    ax : Axes        The axes to draw to    data1 : array       The x data    data2 : array       The y data    param_dict : dict       Dictionary of kwargs to pass to ax.plot    Returns    -------    out : list        list of artists added    \"\"\"    out = ax.plot(data1, data2, **param_dict)    return out\nwhich you would then use as:\ndata1, data2, data3, data4 = np.random.randn(4, 100)fig, ax = plt.subplots(1, 1)my_plotter(ax, data1, data2, {'marker': 'x'})\nMultiple subplotsimport numpy as npimport matplotlib.pyplot as plt\nx1 = np.linspace(0.0, 5.0)x2 = np.linspace(0.0, 2.0)y1 = np.cos(2 * np.pi * x1) * np.exp(-x1)y2 = np.cos(2 * np.pi * x2)fig, (ax1, ax2) = plt.subplots(2, 1)fig.suptitle('A tale of 2 subplots')ax1.plot(x1, y1, 'o-')ax1.set_ylabel('Damped oscillation')ax2.plot(x2, y2, '.-')ax2.set_xlabel('time (s)')ax2.set_ylabel('Undamped')plt.show()\nImage Demoimport numpy as npimport matplotlib.cm as cmimport matplotlib.pyplot as pltimport matplotlib.cbook as cbookfrom matplotlib.path import Pathfrom matplotlib.patches import PathPatch# Fixing random state for reproducibilitynp.random.seed(19680801)\ndelta = 0.025x = y = np.arange(-3., 3., delta)X, Y = np.meshgrid(x, y)Z1 = np.exp(-X**2-Y**2)Z2 = np.exp(-(X--1)**2 - (Y--1)**2)Z = (Z1-Z2)*2fig, ax = plt.subplots()im = ax.imshow(Z, interpolation='bilinear', cmap='rainbow',               origin='lower', extent=[-3, 3, -3, 3],               vmax=abs(Z).max(), vmin=-abs(Z).max())plt.show()\nPolarr = np.arange(0, 2, 0.001)theta = 2 * np.pi * rfig, ax = plt.subplots(subplot_kw={'projection': 'polar'})ax.plot(theta, r)ax.set_rmax(2)ax.set_rticks([0.5, 1, 1.5, 2])  # less radial ticksax.set_rlabel_position(-22.5)  # Move radial labels away from plotted lineax.grid(True)ax.set_title('A line plot on a polar axis')plt.show()\nZoomdelta = 0.001x = y = np.arange(-3., 3., delta)extent = [-3, 3, -3, 3]X, Y = np.meshgrid(x, y)Z1 = np.exp(-X ** 2 - Y ** 2)Z2 = np.exp(-(X - -1) ** 2 - (Y - -1) ** 2)Z = (Z1 - Z2) * 2fig, ax = plt.subplots()im = ax.imshow(Z, interpolation='bilinear', cmap='rainbow',                       origin='lower', extent=extent,                       vmax=abs(Z).max(), vmin=-abs(Z).max())# inset axesaxins = ax.inset_axes([0.6, 0.6, 0.4, 0.4]) # location and enlarge factoraxins.imshow(Z, extent=extent, origin='lower', cmap='rainbow')# subregion of the original imagex1, x2, y1, y2 = -0.75, 0.25, -1.25, -0.25axins.set_xlim(x1, x2)axins.set_ylim(y1, y2)axins.set_xticklabels('')axins.set_yticklabels('')ax.indicate_inset_zoom(axins, edgecolor=\"black\")plt.show()\nCode Hintingcommentsuse Type hinting\nfrom matplotlib import pyplot as pltimport matplotlib.axes._axes as axesimport matplotlib.figure as figurefig, ax = plt.subplots()  # type:figure.Figure, axes.Axesax.  # &lt;- now autocompletesfig.  # &lt;- now autocompletes\nuse assert isinstancefrom matplotlib import pyplot as pltimport matplotlib.axes._axes as axesimport matplotlib.figure as figurefig, ax = plt.subplots()assert isinstance(fig, figure.Figure)assert isinstance(ax, axes.Axes)ax.  # &lt;- now autocompletesfig.  # &lt;- now autocompletes\n","categories":["code"],"tags":["matplotlib,可视化,科研"]},{"title":"体系的概念","url":"/2023/05/03/%E4%BD%93%E7%B3%BB%E7%9A%84%E6%A6%82%E5%BF%B5/","content":"什么是体系（System of Systems，SoS）我们知道，系统（System）是相互关联的元素或部分组合在一起构成的整体。那什么是体系呢？体系是更高层次的系统，是系统的系统，由多个在功能上相对独立的系统构成，通过一定方式的协调组合，共同实现单个系统不具备且多个系统简单叠加也无法实现的综合能力和整体效能。由此可见，相对于系统来说，体系具有更高的复杂性。体系与系统的比较如下表所示。\n\n\n\n\n比较点\n体系\n系统\n\n\n\n\n能力需求\n功能和能力需求多样化\n功能和能力需求比较单一\n\n\n构成\n多个复杂系统集成\n由系统的组成部分构成\n\n\n规模\n规模庞大，全局的，地理分布范围广泛\n规模较小，区域的，分布比较集中\n\n\n边界\n边界不明确，体系间有较强交互\n边界明确，系统间较少交互\n\n\n组件关系\n系统间松耦合，协同工作，相互补充\n组件间紧耦合，相互依赖，缺一不可\n\n\n复杂性\n层次结构和组件关联方式复杂\n层次结构和组件关联方式简单\n\n\n生命周期\n不确定，无限长的生命周期\n比较确定，固定的生命周期\n\n\n优化\n很复杂，较难优化\n在公认的指标上优化\n\n\n信息流\n潜在改变的信息流和普遍的信息共享\n很好理解的信息流\n\n\n演化性\n随需求和技术的变化不断演化发展\n较少改进，注重系统自身功能的提高\n\n\n采办开发\n由多个权力机构控制开发\n单个权力机构开发\n\n\n\n\n什么体系架构（System of Systems Architecture，SoSA）要理解体系架构的概念，首先需要搞清楚什么是架构（Architecture）。通俗地讲，架构是经过系统性地思考，权衡利弊之后在现有资源约束下的最合理决策，最终明确的系统骨架。架构包括子系统、模块、组件，以及他们之间协作关系、约束规范、指导原则。\n那什么体系架构呢？计算机领域也有体系架构的概念，我们这里只在系统科学范畴讨论体系架构。体系架构通常也称为体系结构，它是系统各组分的结构、它们之间的关系以及指导其设计和随时间演化的原则与指南。体系架构表现了体系组成及其相互关系，明确了系统之间的边界、接口和约束关系，科学地勾画了体系的建设蓝图。利用体系架构可以指导体系的顶层规划、设计、论证和实现，实现各种系统的综合集成，提高系统之间的互操作，同时也可以指导体系的运行。\n什么是体系架构框架（System of Systems Architecture Framework，SoSAF）我们还是先来理解一下框架（Framework）的概念。在软件领域，框架是组件实现的规范，例如：MVC、MVP、MVVM等框架，是提供基础功能的产品，例如开源框架：Ruby on Rails、Spring、Laravel、Django等，这是可以拿来直接使用或者在此基础上二次开发。由此可见，框架为了实现某个业界标准或完成特定基本任务的软件组件规范，按照规范提供所要求基础功能的软件产品。\n体系架构框架是用于体系结构描述的方法、过程、视角、模型的集合。体系结构框架为体系结构描述提供一个统一框架，在这个框架下，建模人员从不同视角和关注点来收集获取体系结构数据，为分类、组织体系结构数据提供依据，并为体系结构模型的开发提供过程指导以及原则指南，确保对体系结构的理解、比较和集成有一个统一的标准。目前知名的体系架构框架有：The Open Group提出的TOGAF、美国国防部提出的DoDAF、英国国防部提出的MoDAF、北约的NAF、对象管理组织提出的统一体系架构框架UAF等。\n什么是体系工程（System of Systems Engineering，SoSE）为了应对“体系”在规划设计、分析、组织、集成过程中出现的一系列新问题，如|互联、互通、互操作、复杂性、导向涌现性、发展演化性等问题，研究人员在系统工程的理论基础上，提出了体系工程的概念。与系统工程相比，体系工程更注重研究复杂大系统的体系结构、各组分之问的相互协调与相互操作问题、与环境的关系以及体系的发展和演化问题，更注重体系整体能力的提升。由此可见，体系工程是通过设计、开发和集成复杂大系统来完成特定任务并获得期望的效果，实现能力、使命或期望结果的理论、方法和技术。\n[[从“基于模型”到“基于模型和仿真”的系统架构设计建模——通过仿真实现高质量系统定义]]\n","categories":["工作"],"tags":["建模"]},{"title":"忘记sql密码怎么办","url":"/2023/05/03/%E5%BF%98%E8%AE%B0sql%E5%AF%86%E7%A0%81%E6%80%8E%E4%B9%88%E5%8A%9E/","content":"日常工作中我们总会遇见忘记sql密码，这时我们只要做到如下几步：\n\n关闭sql\n跳过权限表\n重置密码\n重启sql\n\n\n关闭sql以管理员身份打开cmd输入：\nnet stop sql\n跳过权限表在命令行窗口输入：\nmysqld --skip-grant-tables\n重置密码\n打开另一个cmd窗口，输入mysql进入数据库\n输入show databases;看到数据库说明进入成功\n权限表放在mysql.user中\n输入SELECT user, host, plugin, authentication_string from mysql.user;可以看见用户和加密后的密码\n  注意，plugin插件代表加密方式，mysql自带的是mysql_native_password\n\n\n更改root密码，输入update user set password=password('123456') where user='root' and host='localhost';\n再次查看密码，输入SELECT user, host, plugin, authentication_string from mysql.user;\n\n重启mysql\n关闭cmd，并手动停止mysqld的运行\n输入net start mysql重启mysql\n输入’mysql -u root -p 123456’登录mysql\n\n","categories":["code"],"tags":["密码,SQL"]},{"title":"MySQL学习笔记","url":"/2023/05/03/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"终端操作进入数据库\nmysql -u root -p 123456\n如何查看有什么数据库 show databases;\nmysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || shop               || sys                |+--------------------+5 rows in set (0.00 sec)\n如何选择数据库 use shop如何查看该数据库中有哪些表mysql&gt; show tables;+--------------------------------------------+| Tables_in_shop                             |+--------------------------------------------+| adminmodules                               || auth_group                                 || auth_group_permissions                     || auth_permission                            || auth_user                                  || auth_user_groups                           || auth_user_user_permissions                 || course                                     || django_admin_log                           || django_content_type                        || django_migrations                          || django_session                             || login                                      || position                                   || product                                    || productcategory                            || registration_registrationprofile           || registration_supervisedregistrationprofile || saleslist                                  || saleslistdetail                            || score                                      || shop_position                              || student                                    || teacher                                    |+--------------------------------------------+24 rows in set (0.00 sec)\n如何查看表中的数据mysql&gt; select * from position;+------------+--------------+----------------------+| PositionId | PositionName | Description          |+------------+--------------+----------------------+|          1 | 管理员       | 负责管理超市！       ||          2 | 收银员       | 负责管理的收银工作！ |+------------+--------------+----------------------+2 rows in set (0.00 sec)\n如何退出数据库服务器 exit or ctrl+z如何在数据库中创建自己的数据库 create database dataBaseName如何创建数据表？petcreate table pet(name varchar(20),owner varchar(20),species varchar(20),sex char(1),birth datetime,death datetime);\n\n\nvar()与varchar()的区别在于var()是定常的,哪怕存储的字符串没有达到”()”中数字的上限,var()依然会占用空格来填充空间.而varchar()则是不定长的,没有达到”()”中的上限则会自动去掉后面的空格;\n\n性别不要用:sex 要用:gender 一个是性 一个是性别;\n\n定义最后一个字段的时候不要加”,”;\n上面的”VAR”,”VARCHAR”,”DATE”可以用小写.不过最好用大写来表示区分关键字,若不然也许写到后面你自己都不知道这个词是数据库中的关键字还是你自己自定义的一些数据,同时一定要用英文的标点符号也必须半角输入\n\n\n如何查看表的架构mysql&gt; desc product;+-------------+--------------+------+-----+---------+-------+| Field       | Type         | Null | Key | Default | Extra |+-------------+--------------+------+-----+---------+-------+| ProductId   | varchar(20)  | NO   | PRI | NULL    |       || BarCode     | varchar(20)  | YES  | UNI | NULL    |       || ProductName | varchar(100) | NO   |     | NULL    |       || Unit        | varchar(20)  | NO   |     | NULL    |       || UnitPrice   | float        | NO   |     | NULL    |       || CategoryId  | tinyint(4)   | YES  | MUL | NULL    |       || Inventory   | int(11)      | NO   |     | NULL    |       |+-------------+--------------+------+-----+---------+-------+7 rows in set (0.00 sec)\n如何插入数据INSERT INTO pet VALUES('kk','cc','dog','1','1998-8-2',null);INSERT INTO pet(name,owner) VALUES ('xx','cc');\n\n\n\n\n\nname\nowner\nspecies\nsex\nbirth\ndeath\n\n\n\n\nkk\ncc\ndog\n1\n1998-08-02\nnull\n\n\n\n\n  NULL:代表的是空,表示该字段还没有数据.千万不要主动填写’NULL’,这代表你的字段有一个值叫做’null’.\n\nMYSQL常用类型\n  金钱最好用int/bigint,使用浮点会有精度损失\n\n如何删除数据\n删除 DELETE FROM tablename WHERE condition;\n修改 UPDATE tablename SET 字段1=值1,字段2=值2 ... WHERE 条件;\n\n表中的约束主键约束它能够唯一确定一张表中的一条记录,增加主键约束之后,就可以使得字段不重复而且不为空  \ncreate table user(    id int PRIMARY KEY,    name VARCHAR(20));INSERT INTO user VALUES (1,'张三');+----+------+| id | name |+----+------+|  1 | 张三 |+----+------+运行DESCRIBE user;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id    | int(11)     | NO   | PRI | NULL    |       || name  | varchar(20) | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+发现 id是不可以为null 而且 key的值 也变为:PRI(primary)\n复合主键CREATE TABLE user2(    id INT,    name VARCHAR(20),    password VARCHAR(20),    PRIMARY key(id,name));运行DESCRIBE user2;+----------+-------------+------+-----+---------+-------+| Field    | Type        | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id       | int(11)     | NO   | PRI | NULL    |       || name     | varchar(20) | NO   | PRI | NULL    |       || password | varchar(20) | YES  |     | NULL    |       |+----------+-------------+------+-----+---------+-------+INSERT INTO user2 VALUES (1,'老王','123456');INSERT INTO user2 VALUES (2,'老王','123456');+----+------+----------+| id | name | password |+----+------+----------+|  1 | 老王 | 123456   ||  2 | 老王 | 123456   |+----+------+----------+\n只要所有的字段都不是相同的情况下可以允许其中的字段重复\n自增约束CREATE TABLE user3(    id INT PRIMARY KEY AUTO_INCREMENT,    name VARCHAR(20));运行DESCRIBE user3;+-------+-------------+------+-----+---------+----------------+| Field | Type        | Null | Key | Default | Extra          |+-------+-------------+------+-----+---------+----------------+| id    | int(11)     | NO   | PRI | NULL    | auto_increment || name  | varchar(20) | YES  |     | NULL    |                |+-------+-------------+------+-----+---------+----------------+INSERT INTO user3(name) VALUES('张三');INSERT INTO user3(name) VALUES('李四');+----+------+| id | name |+----+------+|  1 | 张三 ||  2 | 李四 |+----+------+没有自定义id值 但是自动生成了id\n唯一约束CREATE TABLE user5(    id INT PRIMARY KEY AUTO_INCREMENT,    name VARCHAR(20));运行 DESCRIBE user5;+-------+-------------+------+-----+---------+----------------+| Field | Type        | Null | Key | Default | Extra          |+-------+-------------+------+-----+---------+----------------+| id    | int(11)     | NO   | PRI | NULL    | auto_increment || name  | varchar(20) | YES  |     | NULL    |                |+-------+-------------+------+-----+---------+----------------+新增name为唯一约束:ALTER TABLE user5 ADD UNIQUE(name);运行 DESCRIBE user5;+-------+-------------+------+-----+---------+----------------+| Field | Type        | Null | Key | Default | Extra          |+-------+-------------+------+-----+---------+----------------+| id    | int(11)     | NO   | PRI | NULL    | auto_increment || name  | varchar(20) | YES  | UNI | NULL    |                |+-------+-------------+------+-----+---------+----------------+测试:插入数据INSERT INTO user5(name) VALUES ('cc');运行 SELECT * FROM user5; 查看结果:+----+------+| id | name |+----+------+|  1 | cc   |+----+------+再次插入INSERT INTO user5(name) VALUES ('cc');出现:ERROR 1062 (23000): Duplicate entry 'cc' for key 'name'换个试试 INSERT INTO user5(name) VALUES ('aa');运行 SELECT * FROM user5; 查看结果:+----+------+| id | name |+----+------+|  3 | aa   ||  1 | cc   |+----+------+\n主键约束(primary key)中包含了唯一约束场景:设计一张用户注册表,用户姓名必须要用手机号来注册,而且手机号和用户名称都不能为空,那么:\nCREATE TABLE user_test(    id INT PRIMARY KEY AUTO_INCREMENT COMMENT'主键id',    name VARCHAR(20) NOT NULL COMMENT'用户姓名,不能为空',    phone_number VARCHAR(20) UNIQUE NOT NULL COMMENT'用户手机,不能重复且不能为空');运行 DESCRIBE user_test;+--------------+-------------+------+-----+---------+----------------+| Field        | Type        | Null | Key | Default | Extra          |+--------------+-------------+------+-----+---------+----------------+| id           | int(11)     | NO   | PRI | NULL    | auto_increment || name         | varchar(20) | NO   |     | NULL    |                || phone_number | int(11)     | NO   | UNI | NULL    |                |+--------------+-------------+------+-----+---------+----------------+\n这样的话就达到了每一个手机号都只能出现一次,达到了每个手机号只能被注册一次.用户姓名可以重复,但是手机号码却不能重复,复合正常的逻辑需求\n非空约束name和phone_number都设置了非空,先只设置name参数不设置phone_number参数试一试INSERT INTO user_test (name) VALUES ('张三');会出现Field 'phone_number' doesn't have a default value两个非空参数一起设置:INSERT INTO user_test (name,phone_number) VALUES ('张三','12345678901');+----+------+--------------+| id | name | phone_number |+----+------+--------------+|  1 | 张三 | 12345678901  |+----+------+--------------+\n默认约束CREATE TABLE user6(   id int PRIMARY KEY AUTO_INCREMENT COMMENT'主键id',    name VARCHAR(20) NOT NULL COMMENT'用户姓名不能为空',    phone_number VARCHAR(20) NOT NULL COMMENT'用户手机号,不能为空',    status INT DEFAULT 0 COMMENT'用户状态0:启用 1:禁封 默认:0');运行DESCRIBE user6;+--------------+-------------+------+-----+---------+----------------+| Field        | Type        | Null | Key | Default | Extra          |+--------------+-------------+------+-----+---------+----------------+| id           | int(11)     | NO   | PRI | NULL    | auto_increment || name         | varchar(20) | NO   |     | NULL    |                || phone_number | varchar(20) | NO   |     | NULL    |                || status       | int(11)     | YES  |     | 0       |                |+--------------+-------------+------+-----+---------+----------------+插入数据:INSERT INTO user6(name,phone_number) VALUES ('aa','123');INSERT INTO user6(name,phone_number) VALUES('bb','1234');INSERT INTO user6(name,phone_number) VALUES('cc','1263456');查看数据:SELECT * FROM user6;+----+------+--------------+--------+| id | name | phone_number | status |+----+------+--------------+--------+|  1 | aa   | 123          |      0 ||  2 | bb   | 1234         |      0 ||  3 | cc   | 1263456      |      0 |+----+------+--------------+--------+\n我们没有设置status的值,但是给我们创建了默认值0.\n应用场景:找正常的用户\n对这些正常用户进行发放优惠卷或者积分之类的东西,而被禁封的用户我们不让其参加多动.我们想要封用户只要将status的值从0改为1就行了,当然我们取用户的时候必须要先判断status是否是0.若是1.说明该用户已经被禁封.先封手机号为’1234’的用户:\nUPDATE user6 SET status = 1 WHERE phone_number= '1234';SELECT * FROM user6;+----+------+--------------+--------+| id | name | phone_number | status |+----+------+--------------+--------+|  1 | aa   | 123          |      0 ||  2 | bb   | 1234         |      1 ||  3 | cc   | 1263456      |      0 |+----+------+--------------+--------+status为1,说明用户已经被封,该用户不可以参加活动我们取用户的时候加上status的判断,如:SELECT * FROM user6 WHERE status = 0;+----+------+--------------+--------+| id | name | phone_number | status |+----+------+--------------+--------+|  1 | aa   | 123          |      0 ||  3 | cc   | 1263456      |      0 |+----+------+--------------+--------+\n外键约束CREATE TABLE classes(    id INT PRIMARY KEY AUTO_INCREMENT COMMENT'班级表id',    name VARCHAR(20) COMMENT'班级名称');运行DESCRIBE classes;+-------+-------------+------+-----+---------+----------------+| Field | Type        | Null | Key | Default | Extra          |+-------+-------------+------+-----+---------+----------------+| id    | int(11)     | NO   | PRI | NULL    | auto_increment || name  | varchar(20) | YES  |     | NULL    |                |+-------+-------------+------+-----+---------+----------------+CREATE TABLE student(   id INT PRIMARY KEY AUTO_INCREMENT COMMENT'学生表id',   name VARCHAR(20) COMMENT'学生姓名',    class_id int COMMENT'教室id,这张表中的class_id是classes表中id的值',    FOREIGN KEY (class_id) REFERENCES classes(id));//FOREIGN :外来  REFERENCES:应用,参考运行DESCRIBE student;+----------+-------------+------+-----+---------+----------------+| Field    | Type        | Null | Key | Default | Extra          |+----------+-------------+------+-----+---------+----------------+| id       | int(11)     | NO   | PRI | NULL    | auto_increment || name     | varchar(20) | YES  |     | NULL    |                || class_id | int(11)     | YES  | MUL | NULL    |                |+----------+-------------+------+-----+---------+----------------+\n班级插入数据:\nINSERT INTO CLASSES (name) VALUES ('一班');INSERT INTO CLASSES (name) VALUES ('二班');INSERT INTO CLASSES (name) VALUES ('三班');INSERT INTO CLASSES (name) VALUES ('四班');\n查看数据:\nSELECT * FROM classes;+----+------+| id | name |+----+------+|  1 | 一班 ||  2 | 二班 ||  3 | 三班 ||  4 | 四班 |+----+------+\n学生插入数据:\nINSERT INTO student (name,class_id) VALUES ('小赵',1);INSERT INTO student (name,class_id) VALUES ('小钱',2);INSERT INTO student (name,class_id) VALUES ('小孙',3);INSERT INTO student (name,class_id) VALUES ('小李',4);\n查看数据:\n+----+------+----------+| id | name | class_id |+----+------+----------+|  1 | 小赵 |        1 ||  2 | 小钱 |        2 ||  3 | 小孙 |        3 ||  4 | 小李 |        4 |+----+------+----------+\n若是像插入班级为5的数据 \n如:INSERT INTO student (name,class_id) VALUES ('小周',5);\n报错:Cannot add or update a child row我们删除正在被学生表引用的’四班’试试:\nDELETE classes WHERE name = '四班';\n出现:Cannot delete or update a parent row:不能删除主表中的行\n我们先删除学生表中的 ‘小李’从而解除班级中’四班’的外键约束,再来删除’四班’(因为小李引用了四班)\nDELETE FROM student WHERE name = '小李';\n再次删除classes表中的’四班’\nDELETE FROM classes WHERE name = '四班';\n最后: \nSELECT * FROM classes;+----+------+| id | name |+----+------+|  1 | 一班 ||  2 | 二班 ||  3 | 三班 |+----+------+\n‘四班’被成功删除!\n\n\n主表中没有的数据,在附表中,是不可以使用的.\n主表中记录的数据现在正在被附表所引用,那么主表中正在被引用的数据不可以被删除\n若要想删除,先将附表中的数据删除在删除主表数据\n对于外键约束大家可以联想 省,市 来进行联想 (市必须要依赖于省,只要省还有一个市在引用,那么就不可以删除省,要不然市就没有省了. 那么我们想删除省,必须要将该省下所有的市全部删除之后,才可以删除这个省)\n\n\n如何建表之后添加主键约束CREATE TABLE user4(    id INT,    name VARCHAR(20));mysql&gt; desc user;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id    | int(11)     | YES  |     | NULL    |       || name  | varchar(20) | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+\n加入主键约束ALTER TABLE user ADD PRIMARY KEY(id)后\nmysql&gt; ALTER TABLE user ADD PRIMARY KEY(id);Query OK, 0 rows affected (0.59 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc user;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id    | int(11)     | NO   | PRI | NULL    |       || name  | varchar(20) | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec)\n删除主键约束:ALTER TABLE user DROP PRIMARY KEY\nmysql&gt; ALTER TABLE user DROP PRIMARY KEY;Query OK, 0 rows affected (1.08 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc user;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id    | int(11)     | NO   |     | NULL    |       || name  | varchar(20) | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec)\n使用modify修改字段，添加约束ALTER TABLE user MODIFY id INT PRIMARY KEY\nmysql&gt; ALTER TABLE user MODIFY id INT PRIMARY KEY;Query OK, 0 rows affected (0.54 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc user;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id    | int(11)     | NO   | PRI | NULL    |       || name  | varchar(20) | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+\n给主键设置自增长:ALTER TABLE user4 MODIFY id INT AUTO_INCREMENT;\nmysql&gt; ALTER TABLE user MODIFY id INT AUTO_INCREMENT;Query OK, 0 rows affected (0.67 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; desc user;+-------+-------------+------+-----+---------+----------------+| Field | Type        | Null | Key | Default | Extra          |+-------+-------------+------+-----+---------+----------------+| id    | int(11)     | NO   | PRI | NULL    | auto_increment || name  | varchar(20) | YES  |     | NULL    |                |+-------+-------------+------+-----+---------+----------------+2 rows in set (0.00 sec)\n数据的增删改查\n增加INSERT INTO tablename [(indexes)] VAULES (values);\n删除DELETE tablename WHERE condition;\n修改UPDATE tablename SET index=value WHERE condition;\n查询SELECT items FROM tablename WHERE condition;\n\nMySQL的连接查询（4种）准备用于测试连接查询的数据：\nCREATE DATABASE testJoin;CREATE TABLE person (    id INT,    name VARCHAR(20),    cardId INT);CREATE TABLE card (    id INT,    name VARCHAR(20));INSERT INTO card VALUES (1, '饭卡'), (2, '建行卡'), (3, '农行卡'), (4, '工商卡'), (5, '邮政卡');SELECT * FROM card;+------+-----------+| id   | name      |+------+-----------+|    1 | 饭卡      ||    2 | 建行卡    ||    3 | 农行卡    ||    4 | 工商卡    ||    5 | 邮政卡    |+------+-----------+INSERT INTO person VALUES (1, '张三', 1), (2, '李四', 3), (3, '王五', 6);SELECT * FROM person;+------+--------+--------+| id   | name   | cardId |+------+--------+--------+|    1 | 张三   |      1 ||    2 | 李四   |      3 ||    3 | 王五   |      6 |+------+--------+--------+\n分析两张表发现，person 表并没有为 cardId 字段设置一个在 card 表中对应的 id 外键。如果设置了的话，person 中 cardId 字段值为 6 的行就插不进去，因为该 cardId 值在 card 表中并没有。\n内连接 inner join or join要查询这两张表中有关系的数据，可以使用 INNER JOIN ( 内连接 ) 将它们连接在一起。\n-- INNER JOIN: 表示为内连接，将两张表拼接在一起。-- on: 表示要执行某个条件。SELECT * FROM person INNER JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    |+------+--------+--------+------+-----------+-- 将 INNER 关键字省略掉，结果也是一样的。-- SELECT * FROM person JOIN card on person.cardId = card.id;\n\n  注意：card 的整张表被连接到了右边。\n\n左连接 left join or left outer ioin完整显示左边的表 ( person ) ，右边的表如果符合条件就显示，不符合则补 NULL 。\n-- LEFT JOIN 也叫做 LEFT OUTER JOIN，用这两种方式的查询结果是一样的。SELECT * FROM person LEFT JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    ||    3 | 王五   |      6 | NULL | NULL      |+------+--------+--------+------+-----------+\n右连接 right join or right outer join完整显示右边的表 ( card ) ，左边的表如果符合条件就显示，不符合则补 NULL 。\nSELECT * FROM person RIGHT JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    || NULL | NULL   |   NULL |    2 | 建行卡    || NULL | NULL   |   NULL |    4 | 工商卡    || NULL | NULL   |   NULL |    5 | 邮政卡    |+------+--------+--------+------+-----------+\n完全外连接 full join or full outer join完整显示两张表的全部数据。\n-- MySQL 不支持这种语法的全外连接-- SELECT * FROM person FULL JOIN card on person.cardId = card.id;-- 出现错误：-- ERROR 1054 (42S22): Unknown column 'person.cardId' in 'on clause'-- MySQL全连接语法，使用 UNION 将两张表合并在一起。SELECT * FROM person LEFT JOIN card on person.cardId = card.idUNIONSELECT * FROM person RIGHT JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    ||    3 | 王五   |      6 | NULL | NULL      || NULL | NULL   |   NULL |    2 | 建行卡    || NULL | NULL   |   NULL |    4 | 工商卡    || NULL | NULL   |   NULL |    5 | 邮政卡    |+------+--------+--------+------+-----------+\n事务在 MySQL 中，事务其实是一个最小的不可分割的工作单元。事务能够保证一个业务的完整性。\n比如我们的银行转账：\n-- a -&gt; -100UPDATE user set money = money - 100 WHERE name = 'a';-- b -&gt; +100UPDATE user set money = money + 100 WHERE name = 'b';\n在实际项目中，假设只有一条 SQL 语句执行成功，而另外一条执行失败了，就会出现数据前后不一致。\n因此，在执行多条有关联 SQL 语句时，事务可能会要求这些 SQL 语句要么同时执行成功，要么就都执行失败。\n如何控制事务 - COMMIT / ROLLBACK在 MySQL 中，事务的自动提交状态默认是开启的。\n-- 查询事务的自动提交状态SELECT @@AUTOCOMMIT;+--------------+| @@AUTOCOMMIT |+--------------+|            1 |+--------------+\n自动提交的作用：当我们执行一条 SQL 语句的时候，其产生的效果就会立即体现出来，且不能回滚。\n什么是回滚？举个例子：\nCREATE DATABASE bank;USE bank;CREATE TABLE user (    id INT PRIMARY KEY,    name VARCHAR(20),    money INT);INSERT INTO user VALUES (1, 'a', 1000);SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 |+----+------+-------+\n可以看到，在执行插入语句后数据立刻生效，原因是 MySQL 中的事务自动将它提交到了数据库中。那么所谓回滚的意思就是，撤销执行过的所有 SQL 语句，使其回滚到最后一次提交数据时的状态。\n在 MySQL 中使用 ROLLBACK 执行回滚：\n-- 回滚到最后一次提交ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 |+----+------+-------+\n由于所有执行过的 SQL 语句都已经被提交过了，所以数据并没有发生回滚。那如何让数据可以发生回滚？\n-- 关闭自动提交SET AUTOCOMMIT = 0;-- 查询自动提交状态SELECT @@AUTOCOMMIT;+--------------+| @@AUTOCOMMIT |+--------------+|            0 |+--------------+\n将自动提交关闭后，测试数据回滚：\nINSERT INTO user VALUES (2, 'b', 1000);-- 关闭 AUTOCOMMIT 后，数据的变化是在一张虚拟的临时数据表中展示，-- 发生变化的数据并没有真正插入到数据表中。SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 ||  2 | b    |  1000 |+----+------+-------+-- 数据表中的真实数据其实还是：+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 |+----+------+-------+-- 由于数据还没有真正提交，可以使用回滚ROLLBACK;-- 再次查询SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 |+----+------+-------+\n那如何将虚拟的数据真正提交到数据库中？使用 COMMIT :\nINSERT INTO user VALUES (2, 'b', 1000);-- 手动提交数据（持久性），-- 将数据真正提交到数据库中，执行后不能再回滚提交过的数据。COMMIT;-- 提交后测试回滚ROLLBACK;-- 再次查询（回滚无效了）SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 ||  2 | b    |  1000 |+----+------+-------+\n\n  总结\n\n自动提交\n\n查看自动提交状态：SELECT @@AUTOCOMMIT ；\n设置自动提交状态：SET AUTOCOMMIT = 0 。\n\n\n手动提交\n@@AUTOCOMMIT = 0 时，使用 COMMIT 命令提交事务。\n\n事务回滚\n@@AUTOCOMMIT = 0 时，使用 ROLLBACK 命令回滚事务。\n\n\n\n事务的实际应用，让我们再回到银行转账项目：\n-- 转账UPDATE user set money = money - 100 WHERE name = 'a';-- 到账UPDATE user set money = money + 100 WHERE name = 'b';SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |   900 ||  2 | b    |  1100 |+----+------+-------+\n这时假设在转账时发生了意外，就可以使用 ROLLBACK 回滚到最后一次提交的状态：\n-- 假设转账发生了意外，需要回滚。ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 ||  2 | b    |  1000 |+----+------+-------+\n这时我们又回到了发生意外之前的状态，也就是说，事务给我们提供了一个可以反悔的机会。假设数据没有发生意外，这时可以手动将数据真正提交到数据表中：COMMIT 。\n手动开启事务 - BEGIN / START TRANSACTION事务的默认提交被开启 ( @@AUTOCOMMIT = 1 ) 后，此时就不能使用事务回滚了。但是我们还可以手动开启一个事务处理事件，使其可以发生回滚：\n-- 使用 BEGIN 或者 START TRANSACTION 手动开启一个事务-- START TRANSACTION;BEGIN;UPDATE user set money = money - 100 WHERE name = 'a';UPDATE user set money = money + 100 WHERE name = 'b';-- 由于手动开启的事务没有开启自动提交，-- 此时发生变化的数据仍然是被保存在一张临时表中。SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |   900 ||  2 | b    |  1100 |+----+------+-------+-- 测试回滚ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 ||  2 | b    |  1000 |+----+------+-------+\n仍然使用 COMMIT 提交数据，提交后无法再发生本次事务的回滚。\nBEGIN;UPDATE user set money = money - 100 WHERE name = 'a';UPDATE user set money = money + 100 WHERE name = 'b';SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |   900 ||  2 | b    |  1100 |+----+------+-------+-- 提交数据COMMIT;-- 测试回滚（无效，因为表的数据已经被提交）ROLLBACK;\nACID 特征与使用事务的四大特征：\n\nA 原子性：事务是最小的单位，不可以再分割；\nC 一致性：要求同一事务中的 SQL 语句，必须保证同时成功或者失败；\nI 隔离性：事务1 和 事务2 之间是具有隔离性的；\nD 持久性：事务一旦结束 ( COMMIT ) ，就不可以再返回了 ( ROLLBACK ) 。\n\n事务的隔离性事务的隔离性可分为四种 ( 性能从低到高 ) ：\n\nREAD UNCOMMITTED ( 读取未提交 )\n如果有多个事务，那么任意事务都可以看见其他事务的未提交数据。\n\nREAD COMMITTED ( 读取已提交 )\n只能读取到其他事务已经提交的数据。\n\nREPEATABLE READ ( 可被重复读 )\n如果有多个连接都开启了事务，那么事务之间不能共享数据记录，否则只能共享已提交的记录。\n\nSERIALIZABLE ( 串行化 )\n所有的事务都会按照固定顺序执行，执行完一个事务后再继续执行下一个事务的写入操作。\n\n\n查看当前数据库的默认隔离级别：\n-- MySQL 8.x, GLOBAL 表示系统级别，不加表示会话级别。SELECT @@GLOBAL.TRANSACTION_ISOLATION;SELECT @@TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| REPEATABLE-READ                | -- MySQL的默认隔离级别，可以重复读。+--------------------------------+-- MySQL 5.xSELECT @@GLOBAL.TX_ISOLATION;SELECT @@TX_ISOLATION;\n修改隔离级别：\n-- 设置系统隔离级别，LEVEL 后面表示要设置的隔离级别 (READ UNCOMMITTED)。SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;-- 查询系统隔离级别，发现已经被修改。SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| READ-UNCOMMITTED               |+--------------------------------+\n脏读测试 READ UNCOMMITTED ( 读取未提交 ) 的隔离性：\nINSERT INTO user VALUES (3, '小明', 1000);INSERT INTO user VALUES (4, '淘宝店', 1000);SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 |+----+-----------+-------+-- 开启一个事务操作数据-- 假设小明在淘宝店买了一双800块钱的鞋子：START TRANSACTION;UPDATE user SET money = money - 800 WHERE name = '小明';UPDATE user SET money = money + 800 WHERE name = '淘宝店';-- 然后淘宝店在另一方查询结果，发现钱已到账。SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |   200 ||  4 | 淘宝店    |  1800 |+----+-----------+-------+\n由于小明的转账是在新开启的事务上进行操作的，而该操作的结果是可以被其他事务（另一方的淘宝店）看见的，因此淘宝店的查询结果是正确的，淘宝店确认到账。但就在这时，如果小明在它所处的事务上又执行了 ROLLBACK 命令，会发生什么？\n-- 小明所处的事务ROLLBACK;-- 此时无论对方是谁，如果再去查询结果就会发现：SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 |+----+-----------+-------+\n这就是所谓的脏读，一个事务读取到另外一个事务还未提交的数据。这在实际开发中是不允许出现的。\n读取已提交把隔离级别设置为 READ COMMITTED ：\nSET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| READ-COMMITTED                 |+--------------------------------+\n这样，再有新的事务连接进来时，它们就只能查询到已经提交过的事务数据了。但是对于当前事务来说，它们看到的还是未提交的数据，例如：\n-- 正在操作数据事务（当前事务）START TRANSACTION;UPDATE user SET money = money - 800 WHERE name = '小明';UPDATE user SET money = money + 800 WHERE name = '淘宝店';-- 虽然隔离级别被设置为了 READ COMMITTED，但在当前事务中，-- 它看到的仍然是数据表中临时改变数据，而不是真正提交过的数据。SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |   200 ||  4 | 淘宝店    |  1800 |+----+-----------+-------+-- 假设此时在远程开启了一个新事务，连接到数据库。$ mysql -u root -p12345612-- 此时远程连接查询到的数据只能是已经提交过的SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 |+----+-----------+-------+\n但是这样还有问题，那就是假设一个事务在操作数据时，其他事务干扰了这个事务的数据。例如：\n-- 小张在查询数据的时候发现：SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |   200 ||  4 | 淘宝店    |  1800 |+----+-----------+-------+-- 在小张求表的 money 平均值之前，小王做了一个操作：START TRANSACTION;INSERT INTO user VALUES (5, 'c', 100);COMMIT;-- 此时表的真实数据是：SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 ||  5 | c         |   100 |+----+-----------+-------+-- 这时小张再求平均值的时候，就会出现计算不相符合的情况：SELECT AVG(money) FROM user;+------------+| AVG(money) |+------------+|  820.0000  |+------------+\n虽然 READ COMMITTED 让我们只能读取到其他事务已经提交的数据，但还是会出现问题，就是在读取同一个表的数据时，可能会发生前后不一致的情况。\\这被称为*不可重复读现象 ( READ COMMITTED )* 。\n幻读将隔离级别设置为 REPEATABLE READ ( 可被重复读取 ) :\nSET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| REPEATABLE-READ                |+--------------------------------+\n测试 REPEATABLE READ ，假设在两个不同的连接上分别执行 START TRANSACTION :\n-- 小张 - 成都START TRANSACTION;INSERT INTO user VALUES (6, 'd', 1000);-- 小王 - 北京START TRANSACTION;-- 小张 - 成都COMMIT;\n当前事务开启后，没提交之前，查询不到，提交后可以被查询到。但是，在提交之前其他事务被开启了，那么在这条事务线上，就不会查询到当前有操作事务的连接。相当于开辟出一条单独的线程。\n无论小张是否执行过 COMMIT ，在小王这边，都不会查询到小张的事务记录，而是只会查询到自己所处事务的记录：\nSELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 ||  5 | c         |   100 |+----+-----------+-------+\n这是因为小王在此之前开启了一个新的事务 ( START TRANSACTION ) ,那么在他的这条新事务的线上，跟其他事务是没有联系的，也就是说，此时如果其他事务正在操作数据，它是不知道的。\n然而事实是，在真实的数据表中，小张已经插入了一条数据。但是小王此时并不知道，也插入了同一条数据，会发生什么呢？\nINSERT INTO user VALUES (6, 'd', 1000);-- ERROR 1062 (23000): Duplicate entry '6' for key 'PRIMARY'\n报错了，操作被告知已存在主键为 6 的字段。这种现象也被称为幻读，一个事务提交的数据，不能被其他事务读取到。\n串行化顾名思义，就是所有事务的写入操作全都是串行化的。什么意思？把隔离级别修改成 SERIALIZABLE :\nSET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| SERIALIZABLE                   |+--------------------------------+\n还是拿小张和小王来举例：\n-- 小张 - 成都START TRANSACTION;-- 小王 - 北京START TRANSACTION;-- 开启事务之前先查询表，准备操作数据。SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 ||  5 | c         |   100 ||  6 | d         |  1000 |+----+-----------+-------+-- 发现没有 7 号王小花，于是插入一条数据：INSERT INTO user VALUES (7, '王小花', 1000);\n此时会发生什么呢？由于现在的隔离级别是 SERIALIZABLE ( 串行化 ) ，串行化的意思就是：假设把所有的事务都放在一个串行的队列中，那么所有的事务都会按照固定顺序执行，执行完一个事务后再继续执行下一个事务的写入操作 ( 这意味着队列中同时只能执行一个事务的写入操作 ) 。\n根据这个解释，小王在插入数据时，会出现等待状态，直到小张执行 COMMIT 结束它所处的事务，或者出现等待超时。\n","categories":["code"],"tags":["sql"]},{"title":"爱因斯坦求和","url":"/2023/05/03/%E7%88%B1%E5%9B%A0%E6%96%AF%E5%9D%A6%E6%B1%82%E5%92%8C/","content":"1. einsum记法如果你像我一样，发现记住PyTorch/TensorFlow中那些计算点积、外积、转置、矩阵-向量乘法、矩阵-矩阵乘法的函数名字和签名很费劲，那么einsum记法就是我们的救星。einsum记法是一个表达以上这些运算，包括复杂张量运算在内的优雅方式，基本上，可以把einsum看成一种领域特定语言。一旦你理解并能利用einsum，除了不用记忆和频繁查找特定库函数这个好处以外，你还能够更迅速地编写更加紧凑、高效的代码。而不使用einsum的时候，容易出现引入不必要的张量变形或转置运算，以及可以省略的中间张量的现象。此外，einsum这样的领域特定语言有时可以编译到高性能代码，事实上，PyTorch最近引入的能够自动生成GPU代码并为特定输入尺寸自动调整代码的张量理解（Tensor Comprehensions）就基于类似einsum的领域特定语言。此外，可以使用opt einsum和tf einsum opt这样的项目优化einsum表达式的构造顺序。比方说，我们想要将两个矩阵  和  相乘，接着计算每列的和，最终得到向量   。使用爱因斯坦求和约定，这可以表达为：\n\n{\\huge {\\color{SeaGreen} c_{j}} \n=\\sum_{i} \\sum_{k} {\\color{ProcessBlue} A_{i k}}  {\\color{Lavender} B_{k j}} \n={\\color{ProcessBlue} A_{i k}} {\\color{Lavender} B_{k j}} \\cdot\n}这一表达式指明了中的每个元素 $ci是如何计算的，列向量\\mathbf A{i:}乘以行向量\\mathbf B_{:j}，然后求和。注意，在爱因斯坦求和约定中，我们省略了求和符号{\\large}\\Sigma，因为我们隐式地累加重复的下标（这里是k）和输出中未指明的下标（这里是i$ ）。当然，einsum也能表达更基本的运算。比如，计算两个向量  的点积可以表达为：\n\n{\\huge {\\color{SeaGreen} c} \n=\\sum_{i} {\\color{ProcessBlue} a_{i}}  {\\color{Lavender} b_{i}} \n={\\color{ProcessBlue} a_{i}} {\\color{Lavender} b_{i}} \\cdot}在深度学习中，我经常碰到的一个问题是，变换高阶张量到向量。例如，我可能有一个张量，其中包含一个batch中的个训练样本，每个样本是一个长度为的维词向量序列，我想把词向量投影到一个不同的维度  。如果将这个张量记作 ，将投影矩阵记作 ，那么所需计算可以用einsum表达为：\n\n{\\huge {\\color{SeaGreen} C_{ntq}}\n=\\sum_{k} {\\color{ProcessBlue} T_{ntk} {\\color{Lavender} W_{kq}}}\n= {\\color{ProcessBlue} T_{ntk}} {\\color{Lavender} W_{kq}} \\cdot\n}最后一个例子，比方说有一个四阶张量  ，我们想要使用之前的投影矩阵将第三维投影至维，并累加第二维，然后转置结果中的第一维和最后一维，最终得到张量。einsum可以非常简洁地表达这一切：\n\n{\\huge {\\color{SeaGreen} C_{mqn}}\n=\\sum_{t} \\sum_{k}{\\color{ProcessBlue} T_{ntkm} {\\color{Lavender} W_{kq}}}\n= {\\color{ProcessBlue} T_{ntkm}} {\\color{Lavender} W_{kq}} \\cdot\n}注意，我们通过交换下标和（而不是），转置了张量构造结果。\nNumpy、PyTorch、TensorFlow中的einsum [[numpy]]einsum在numpy中实现为np.einsum，在PyTorch中实现为torch.einsum，在TensorFlow中实现为tf.einsum，均使用一致的签名einsum(equation, operands)，其中equation是表示爱因斯坦求和约定的字符串，而operands则是张量序列（在numpy和TensorFlow中是变长参数列表，而在PyTorch中是列表）。例如，我们的第一个例子， $cj = \\sum{i}\\sum{k} A{ik}B_{kj}$ 写成equation字符串就是ik,kj -&gt; j。注意这里(i, j, k)的命名是任意的，但需要一致。\nPyTorch和TensorFlow像numpy支持einsum的好处之一是einsum可以用于神经网络架构的任意计算图，并且可以反向传播。典型的einsum调用格式如下：\nresult = numpy.einsum(\"ij,ijk,ij-&gt;ik\", arg1, arg2, arg3)\n\n{\\huge {\\color{SeaGreen}\\textbf{reslult}}\n= \\text{einsum}(\"\n{\\color{Red}\\Box\\Box},\\ {\\color{ProcessBlue}\\Box\\Box\\Box},\\ {\\color{Lavender}\\Box\\Box}\n\", {\\color{Red} arg1},\\ {\\color{ProcessBlue}arg2},\\ {\\color{Lavender}agr3} )\n}上式中是占位符，表示张量维度。上面的例子中，arg1和arg3是矩阵，arg2是二阶张量，这一einsum运算的结果（result）是矩阵。注意einsum处理的是可变数量的输入。在上面的例子中，einsum指定了三个参数之上的操作，但它同样可以用在牵涉一个参数、两个参数、三个以上参数的操作上。学习einsum的最佳途径是通过学习一些例子，所以下面我们将展示一下，在许多深度学习模型中常用的库函数，用einsum该如何表达（以PyTorch为例）。\n2.1 矩阵转置\n{\\huge {\\color{SeaGreen}B_{ji} = {\\color{Lavender}A_{ij}}}}import torcha = torch.arange(6).reshape(2, 3)torch.einsum('ij-&gt;ji', [a])tensor([[ 0.,  3.],        [ 1.,  4.],        [ 2.,  5.]])\n2.2 求和\n{\\huge {\\color{SeaGreen}b} =\\sum_{i}\\sum_{j}  {\\color{Lavender}A_{ij}}}a = torch.arange(6).reshape(2, 3)torch.einsum('ij-&gt;', [a])tensor(15.)\n2.3 列求和\n{\\huge {\\color{SeaGreen}b_j} = \\sum_{i} {\\color{Lavender}A_{ij}}}a = torch.arange(6).reshape(2, 3)torch.einsum('ij-&gt;j', [a])tensor([ 3.,  5.,  7.])\n2.4 行求和\n{\\huge {\\color{SeaGreen}b_i} = \\sum_{j} {\\color{Lavender}A_{ij}}}a = torch.arange(6).reshape(2, 3)torch.einsum('ij-&gt;i', [a])tensor([  3.,  12.])\n2.5 矩阵-向量相乘\n{\\huge {\\color{SeaGreen}C_i} \n= \\sum_{k} {\\color{Lavender}A_{ik}} {\\color{ProcessBlue}b_k}}a = torch.arange(6).reshape(2, 3)b = torch.arange(3)torch.einsum('ik,k-&gt;i', [a, b])tensor([  5.,  14.])\n2.6 矩阵-矩阵相乘\n{\\huge{\\color{SeaGreen}C_{ij}}\n=\\sum_{k} {\\color{Lavender}A_{ik} {\\color{ProcessBlue}B_{kj}}}\n}a = torch.arange(6).reshape(2, 3)b = torch.arange(15).reshape(3, 5)torch.einsum('ik,kj-&gt;ij', [a, b])tensor([[  25.,   28.,   31.,   34.,   37.],        [  70.,   82.,   94.,  106.,  118.]])\n2.7点积 向量:\n\n{\\huge {\\color{SeaGreen}c} \n= \\sum_{i} {\\color{Lavender}a_i} {\\color{ProcessBlue}b_i}\n}a = torch.arange(3)b = torch.arange(3,6)  # [3, 4, 5]torch.einsum('i,i-&gt;', [a, b])tensor(14.)\n矩阵：\n\n{\\huge {\\color{SeaGreen}c} \n= \\sum_{i}\\sum_{j} {\\color{Lavender}A_{ij}} {\\color{ProcessBlue}B_{ij}}\n}a = torch.arange(6).reshape(2, 3)b = torch.arange(6,12).reshape(2, 3)torch.einsum('ij,ij-&gt;', [a, b])tensor(145.)\n2.8 哈达玛积\n{\\huge {\\color{SeaGreen}C_{ij}} \n= {\\color{Lavender}A_{ij}} {\\color{ProcessBlue}B_{ij}}\n}\\\\\n{\\huge {\\color{SeaGreen}\\mathbf C} = {\\color{Lavender}\\mathbf A} \\circ {\\color{ProcessBlue}\\mathbf B}}a = torch.arange(6).reshape(2, 3)b = torch.arange(6,12).reshape(2, 3)torch.einsum('ij,ij-&gt;ij', [a, b])tensor([[  0.,   7.,  16.],        [ 27.,  40.,  55.]])\n2.9 外积\n{\\huge {\\color{SeaGreen}C_{ij}} \n= {\\color{Lavender}a_{i}} {\\color{ProcessBlue}b_{j}}\n}a = torch.arange(3)b = torch.arange(3,7)torch.einsum('i,j-&gt;ij', [a, b])tensor([[  0.,   0.,   0.,   0.],        [  3.,   4.,   5.,   6.],        [  6.,   8.,  10.,  12.]])\n2.10 batch矩阵相乘\n{\\huge {\\color{SeaGreen}C_{ijl}} \n= \\sum_{k}{\\color{Lavender}A_{ijk}} {\\color{ProcessBlue}B_{ikl}}\n}a = torch.randn(3,2,5)b = torch.randn(3,5,3)torch.einsum('ijk,ikl-&gt;ijl', [a, b])tensor([[[ 1.0886,  0.0214,  1.0690],         [ 2.0626,  3.2655, -0.1465]],        [[-6.9294,  0.7499,  1.2976],         [ 4.2226, -4.5774, -4.8947]],        [[-2.4289, -0.7804,  5.1385],         [ 0.8003,  2.9425,  1.7338]]])\n2.11 张量缩约batch矩阵相乘是张量缩约的一个特例。比方说，我们有两个张量，一个阶张量，一个阶张量。举例来说，我们取，并假定且。我们可以将这两个张量在这两个维度上相乘（A张量的第2、3维度，B张量的3、5维度），最终得到一个新张量，如下所示：\n\n{\\huge {\\color{SeaGreen}C_{pstuv}} \n= \\sum_{q} \\sum_{r} {\\color{Lavender}A_{pqrs}} {\\color{ProcessBlue}B_{tuqvr}}\n}a = torch.randn(2,3,5,7)b = torch.randn(11,13,3,17,5)torch.einsum('pqrs,tuqvr-&gt;pstuv', [a, b]).shapetorch.Size([2, 7, 11, 13, 17])\n2.12 双线性变换如前所述，einsum可用于超过两个张量的计算。这里举一个这方面的例子，双线性变换。\n\n{\\huge {\\color{SeaGreen}D_{ij}} \n= \\sum_{k} \\sum_{l}{\\color{Lavender}A_{ik}} {\\color{ProcessBlue}B_{jkl} {\\color{Orange}C_{il}}}\n}a = torch.randn(2,3)b = torch.randn(5,3,7)c = torch.randn(2,7)torch.einsum('ik,jkl,il-&gt;ij', [a, b, c])tensor([[ 3.8471,  4.7059, -3.0674, -3.2075, -5.2435],        [-3.5961, -5.2622, -4.1195,  5.5899,  0.4632]])\n3. 案例3.1 TreeQN我曾经在实现TreeQN（ arXiv:1710.11417）的等式6时使用了einsum：给定网络层l上的低维状态表示和激活上的转换函数，我们想要计算残差链接的下一层状态表示。\n\n{\\huge \\mathbf z_{l+1}^{a}\n=\\mathbf z_l + \\tanh(\\mathbf W^{a} \\mathbf z_l)}在实践中，我们想要高效地计算大小为B的batch中的维状态表示，并同时计算所有转换函数（即，所有激活A）。我们可以将这些转换函数安排为一个张量，并使用einsum高效地计算下一层状态表示。\nimport torch.nn.functional as Fdef random_tensors(shape, num=1, requires_grad=False):  tensors = [torch.randn(shape, requires_grad=requires_grad) for i in range(0, num)]  return tensors[0] if num == 1 else tensors# 参数# -- [激活数 x 隐藏层维度]b = random_tensors([5, 3], requires_grad=True)# -- [激活数 x 隐藏层维度 x 隐藏层维度]W = random_tensors([5, 3, 3], requires_grad=True)def transition(zl):    # -- [batch大小 x 激活数 x 隐藏层维度]    return zl.unsqueeze(1) + F.tanh(torch.einsum(\"bk,aki-&gt;bai\", [zl, W]) + b)# 随机取样仿造输入# -- [batch大小 x 隐藏层维度]zl = random_tensors([2, 3])transition(zl)\n3.2 注意力让我们再看一个使用einsum的真实例子，实现注意力机制的等式11-13（arXiv:1509.06664）：\n\n{\\huge \\mathbf M_t \n= \\tanh(\\mathbf W^y \\mathbf Y + (\\mathbf W^h \\mathbf h_t + \\mathbf W^r \\mathbf r_{t-1})\\otimes \\mathbf e_L)\\qquad \\mathbf M_t\\in\\R^{k\\times L}}\\\\\n{\\huge \\alpha_t \n= \\text{softmax}(\\mathbf w^T \\mathbf M_t)\\qquad \\mathbf \\alpha_t\\in\\R^{ L}}\\\\\n{\\huge \\mathbf r_t \n= \\mathbf Y \\alpha_{t}^{T}+\\tanh(\\mathbf W^t \\mathbf r_{t-1})\\qquad \\mathbf r_t\\in\\R^{k}}\\\\用传统写法实现这些可要费不少力气，特别是考虑batch实现。einsum是我们的救星！\n# 参数# -- [隐藏层维度]bM, br, w = random_tensors([7], num=3, requires_grad=True)# -- [隐藏层维度 x 隐藏层维度]WY, Wh, Wr, Wt = random_tensors([7, 7], num=4, requires_grad=True)# 注意力机制的单次应用def attention(Y, ht, rt1):    # -- [batch大小 x 隐藏层维度]    tmp = torch.einsum(\"ik,kl-&gt;il\", [ht, Wh]) + torch.einsum(\"ik,kl-&gt;il\", [rt1, Wr])    Mt = F.tanh(torch.einsum(\"ijk,kl-&gt;ijl\", [Y, WY]) + tmp.unsqueeze(1).expand_as(Y) + bM)    # -- [batch大小 x 序列长度]    at = F.softmax(torch.einsum(\"ijk,k-&gt;ij\", [Mt, w]))    # -- [batch大小 x 隐藏层维度]    rt = torch.einsum(\"ijk,ij-&gt;ik\", [Y, at]) + F.tanh(torch.einsum(\"ij,jk-&gt;ik\", [rt1, Wt]) + br)    # -- [batch大小 x 隐藏层维度], [batch大小 x 序列维度]    return rt, at# 取样仿造输入# -- [batch大小 x 序列长度 x 隐藏层维度]Y = random_tensors([3, 5, 7])# -- [batch大小 x 隐藏层维度]ht, rt1 = random_tensors([3, 7], num=2)rt, at = attention(Y, ht, rt1)\n4. 总结einsum是一个函数走天下，是处理各种张量操作的瑞士军刀。话虽如此，einsum满足你一切需要显然夸大其词了。从上面的真实用例可以看到，我们仍然需要在einsum之外应用非线性和构造额外维度（unsqueeze）。类似地，分割、连接、索引张量仍然需要应用其他库函数。\n使用einsum的麻烦之处是你需要手动实例化参数，操心它们的初始化，并在模型中注册这些参数。不过我仍然强烈建议你在实现模型时，考虑下有哪些情况适合使用einsum.\n","categories":["数学"],"tags":["Einstein，机器学习"]},{"title":"狄拉克符号","url":"/2023/05/03/%E7%8B%84%E6%8B%89%E5%85%8B%E7%AC%A6%E5%8F%B7/","content":"概念\n狄拉克符号是将Hilbert空间分为右矢(bra)空间和左矢(ket)空间\n右矢和左矢分别记作和\n\n\n两条原则\n只描述抽象的特殊的态，而不涉及具体的表象，可直接用右矢标记。这里表象可以理解为“坐标系”的意思。\n\n例如：  表示波函数描述的状态， 表示坐标本征值为的本征态，是能量为的能量本征态……这类表示方法，均不涉及具体表象，通常用于直接描述本征态。\n\n表象中的简洁运算\n\n\n狄拉克内积可表示为 ，且有 \n外积 \n\n若左矢和右矢相互正交，则 ，若  归一化过，则 \n在表象F下，存在完全集 ，则任一态矢量  按照基矢  的展开可以记作\n\n|\\psi\\rangle = \\sum\\limits_{k}{a_k \\ |k\\rangle}由于基矢是完备正交的，因此矢量 在其上的基投影量记作 ，对于基矢本身有\n\n\\mathbf I = \\sum\\limits_{k} {|k \\rangle \\langle k|}关于狄拉克符号的一些简洁的记法\n算符：\n本征方程：\n薛定谔方程：\n力学量平均：\n\n假定F表象的基矢记作 ，L表象的基矢记作 ，对于一个量子态 ，两个表象下分别表示为\n\n|\\varphi\\rangle = \\sum\\limits_{f} a_f |f\\rangle \\\\\n|\\varphi\\rangle = \\sum\\limits_{l} a_l |l\\rangle而从表象F到表象L的变换可记作\n\n\\langle f|\\psi \\rangle = \\sum\\limits_{l} \\langle f|l \\rangle \\langle l|\\psi\\rangle即 \n","categories":["数学"]},{"title":"辞退职场“老实人”（上）","url":"/2023/05/03/%E8%BE%9E%E9%80%80%E8%81%8C%E5%9C%BA%E2%80%9C%E8%80%81%E5%AE%9E%E4%BA%BA%E2%80%9D%EF%BC%88%E4%B8%8A%EF%BC%89/","content":"初遇“老实人”老实人曾经和我一个组，平级同事，日常谨小慎微，不善言辞，看起来一副踏实肯干，职场老实人的样子，日常是前领导的小宝贝，每天看起来忙忙碌碌，但最后其实什么也没干。能力上和刚工作6个月的非本专业新人大专生媲美（老实人是博士退学转硕），但由于躺在公司最重要的项目上，周围的人不得不扶着这位走到终点，加上前领导Q偏爱，于是年年优秀拿到手软，也是公司的老员工了。我来公司不久，就和一部分员工被抽调组建新的部门，他也本应是被抽调的一员，但在前领导Q的强烈要求下（他工作能力不行，还是留在我这吧）留在了原部门，对你没看错，前领导Q知道他能力不行，依然是当年的优秀，直到前领导Q因部门没有产出，经常推卸本部门责任与其他部门摩擦等原因，被公司劝退了。树倒猢狲散，部门被拆分，老实人也被塞到了我组。\n我和老实人做同事的时候关系一直不错，一起出过差帮他做项目，觉得老实人虽然能力差点，但心思单纯，而且老实人家里只有他一个人工作，上有老下有小，养家不容易，所以在工作上时常帮他补坑，被评为除了前领导最护着他的人之一。即使是现在面对他板上钉钉要被辞退的现实，我也时不时心软，觉得他在改了在改了，还有变好的可能，但是一想到老实人在我手下的种种表现，以及再续签就是无固定期限合同的未来，就觉得还是算了。\n被通知调来我组的老实人，春节前几天慢悠悠地收拾了东西，其中搬工位就耗费了他一天的精力。好不容易等其驾到，刚要给他安排工作，老实人表示自己要早几天回去，用的依然是通知的语气。我刚升主管不久，本身自己也请了年假，又兼对方比我年纪大又是以前同事，觉得只是他不善言辞，全然没放在心上，谁知这根本不是无心，而是试探我态度的开始罢了。\n因为自己已经请了年假回家，暂时拜托同事X（职级比我高），也是老实人的老同事，给老实人安排年前的工作，不到半天，告状的电话就打过来:“我安排他组装一下新到的椅子，他居然说，这也要我做？！”由于X之前就很看不上老实人，我赶忙安慰X老实人无心之失不会说话，又赶紧给老实人打电话问明情况，结果老实人张嘴第一句仍然就是“这也要我装？”护老实人的我选择循循善诱，直到老实人说“哦，对，我们以前在前领导那有时候也自己装”，然后又交代了几句说话注意语气，别惹X生气，算是平息了这场风波。\n现在从这件事情来看，我是真的挺护着他，也怪不得后面X吐槽:“你是我们之中最护着他的……”\n依然”不善言辞”，对礼貌没有基本常识的老实人。春节后，大家陆陆续续回来了，我详细的规划了工作，只等着老实人年假结束回来就交给他，我一直觉得老实人只是能力差些，但踏实肯干，总能教会。但是接下来老实人开始了他骚操作式的请假。\n因为老婆做手术，老实人在他的假期马上到的前一天，通知我他要请假，语气是“XXX，我老婆做手术，我要请3天假，我已经和F总（部门老大）打过招呼了”，包子如我，不仅没有批评他，反而关心了他老婆的病情。临到三天结束又是三天假，三天复三天地请着，一直请到月底，到了最后连招呼都不打了，直接钉钉上递交了请假申请。我连忙问F总是否知道他要请假，得到的答案是否，F总直接亲自下场敲打了他一顿。老实人仿佛突然懂得了礼貌，连忙和我道歉上表示下次不会再这样了。\n老实人并不是不善交际不懂礼貌，只是你不值得他懂礼貌而已。而看着老实人可怜巴巴道歉的样子，此刻我居然又开始觉得他“只是不善言辞”，心理上一下又可怜起他来，反而觉得自己小题大做了。二月开始，老实人终于姗姗来迟恢复工作了，没想到这才是让我大跌眼镜的开始。\n摸鱼大师级人物的老实人2月，老实人总算正式来上班了，却让我大开眼界，意识到了什么叫摸鱼大师级人物。一开始只是让老实人询一下标准品，给了老实人几个销售的联系方式，告诉他可以问这些人直接要，于是，老实人兢兢业业询了一个礼拜才完成了其他人空余时间就能完成的工作。中间我曾问起，老实人表示某些符合要求的标准品非常难找，自己正在努力上网搜索寻找供应商，得，他倒干起采购的工作来了。到了周五，在我的催促下老实人终于把一个……excel交给了我，而他，作为一个老员工，在完全是清楚正常采购流程的情况下，甚至没有把这个表格交给采购！\n第二周，我让他写一些文件，模板已经给了他，而且以前他是写过相关文件的，于是他继续愉快地摸起了鱼，三天以后，交给了我其中的一篇，不夸张的说换我一下午就能写2份，在我忍不住发火之后，在周五交上了其余的6份文件。\n接下来让他负责某包装参数的优化，又是实验五分钟，等待两三天，“忙碌”了两周，最后给我的反馈是，怎样都会漏气的，最终不了了之。\n3月中旬，一切就位，终于能开始安排他做正经实验了，于是实验小半天之后又神秘消失，问就是在忙，一看，实验小半天，记录写两天。被我训了一次，立刻在2小时内写完。3月底，在我的各种指导下，老实人终于完成了他过去可能要一整年的工作量:解决他之前转产时的历史遗留问题，以及一个方法的验证，当然，问题其实是我解决的，他只负责操作，如果放任他自己做或者想下去，那必定又是一件不了了之，或者别人都无法复现的工作。因为老实人总会将问题的原因归结为某种玄学，比如，离心管在涡旋震荡仪槽上插入的高度严重影响了他的结果，又或是一大堆色谱柱里只有这一根才能复现他神秘的实验，建议我们买一大堆再里面挑一根再创奇迹。\n现在想起，老实人的摸鱼水平也依然让我惊叹，也琢磨不透，因为每次有空你望向他的工位，他永远没有在看手机，而是在电脑上浏览着相关网页。我到现在仍然不知道，他那询标准品的一整周是怎么将时光消磨干净的。\n与其责怪自己，不如指责他人？三月后半月，老实人在我的全程保姆式的安排催促和解决问题之下，终于有了一些能看的工作量，Q1绩效评分在F总那里也蒙混过关。我也终于摸到了对付老实人的方法:明确安排好老实人每一天要完成多少工作量，并且一定要设置明确的DDL，一旦布置类似于“你抽空把这些文件写一写，五月中旬要交”式的工作，那在老实人这里就等于没有布置。\n在这种设置下，整个四月老实人终于开始干起了活，当然，依然是保量不保质，兢兢业业地做出了一堆有问题的数据。过程中大错不犯小错不断，一直犯些新手的低级错误，而每次出错时，他都要将仪器和试剂从上到下怀疑个遍，而从不怀疑是自己的低级错误。以至于某次我无奈地说“承认自己配错了有那么难吗？”的时候，旁边的组员妹妹没忍住笑出了声。\n这让我想起两年前他验证我开发的方法时，因为自身溶液配制问题，和另一个溶液配制困难户（目前也已经在劝退边缘了）联手指责我“方法不好，东西不成线性”，最后隔壁其他项目组的成员一次成功，两人啪啪打脸的经历。时至今日，他依然在犯这样的错误，也依然不会反思自己的问题。老实人的口头禅依然是“这个当初是她做的，我不知道”或者“那这东西就这样，我有啥办法”，以及“那你没告诉过我，我怎么知道”，将与其责怪自己，不如指责他人的精神发挥的淋漓尽致。\n从10分提升至30分，还是不及格——老实人的东窗事发。当我还沉浸在老实人终于做出点东西，自己教导初见成效的时候，base长期在外地的F总出差回来，宣布除周报外，以后每月开一次组会做一页PPT总结一下本月个人工作。万万没想到，就是这一页PPT，成了开除老实人的导火索。\n因为F总让大家直接都把PPT提前一天交给他，于是我让组员都直接交给F总，不用再经手我这里（现在看看，如果当初经过我手，可能还会帮老实人改PPT，他可能甚至不会东窗事发），直到前一天晚上下班六点多，F总问我老实人的PPT怎么还没交，我通知后，老实人才急急忙忙做了PPT交上去。第二天组会，轮到老实人时，我惊恐地发现老实人连自己四月的工作都没写齐全，内容也可以用一句话概括:“我做了一个实验，然后失败了”。我不愧为最护老实人的人之一，此时依然在帮老实人挽尊，解释说实验设计上也有些问题，已经重新又从第0天开始考察了，要继续放置七天。此时，我之前提过的，装椅子事件里的同事，X博，开始了一连串的灵魂拷问。\n让老实人真正陷入宕机状态的问题是，你重新零天开始考察，到五一放假的时候只能做到第五天，你第七天的时候打算怎么办？老实人的心里根本没有节前反序放置7天，节后再补一个数据点的概念，只想着自己的票早已买好，“加班”两字可千万不能说出口，于是会场陷入了死一般的寂静。\n沉默了一会，组员妹妹提出了节前反序放置，这样又不用加班也不用中断实验，可惜这样对老实人来说“新奇”的想法让他本就宕机的大脑再次过载，众人七嘴八舌解释了几遍也没回过味来，领导让他回头慢慢想，会议才得以继续进行下去。\n当天下午三点，F总先是在VX上和我们吐槽“感觉老实人四月份什么也没做”，由于F总和我们一向打成一片，领导风格也是以轻松幽默为主，我本以为F总会要求批评老实人一顿，要求他再接再厉。结果去了他的办公室，F总却说老实人这么简单的实验都能犯错，叫我看看要不要把老实人开除了。\n我组本身就任务重难度高，我正处于极端缺人的状态，于是一直在为老实人解释:他没有放上全部的工作，有些零碎的工作他没有放;他也算0.5个战斗力，总比没有强;他家就一个他养家，年纪也大不容易。F总一一辩驳，并开玩笑说不用担心，到时候多招一个新员工换，谁不好就开除谁……啊，我想，比他还差的员工，可能在面试的时候就会被卡住，怕是也不好招到了。\n接着F总表示，既然做不好实验，就派他去和隔壁部门做些沟通交流写文件的工作，我和X博惊恐摇头，我表示他沟通能力极差根本不能胜任，而X博则从摸鱼的角度指出，这种没有明确节点又能捞功劳的事情绝不能让老实人做。但F总意愿坚决，要求老实人负责沟通交流的工作，表示他再看一个月，如果老实人仍然不改，就让老实人滚蛋。\n一次谈话让我彻底对老实人失望接到任务后，我立刻找到正在做实验的老实人，表示等他有空跟我单独聊一下。看到他忙于实验的样子，我暗感老实人最近已有所改观，仍然抱着一丝侥幸心理，说不定老实人被骂以后能痛定思痛，焕然一新。谁知接下来的谈话却让我大跌眼镜。\n对于工作量少，老实人解释他承认2/3月份做的少，但是这个月做的很多（事实上工作量和刚来半个月的新员工差不多），并且细数起了自己的零碎工作，最后竟然问我“你没和F总说吗？”，被我回怼之后，又解释说自己太过忙于实验，没时间做那一页PPT。\n对于会上X博的灵魂拷问，我问他本来打算怎么办？“我本来觉得这次实验也会失败，所以我先做几天看看。”“万一成功了呢？”“万一成功我就先拿5天的数据，然后节后再来重头做起。”我还是第一次见祈祷自己实验失败的实验人，合着这位的小算盘打的都是实验失败。狠狠训斥了他一顿之后，老实人表示自己要加油努力提高工作量，下次再也不会了。\n临离开前，老实人又主动聊起了PPT，并且抱怨自己没收到通知。我拿起微信里的聊天记录，当场指给他看自己两天前发布的通知。谁知老实人见状，又说了一句令人吐血的话:“你只说要做，没说要交给F总。”（交给F总我是口头在办公室通知了所有组员）我说你不交给F总，交给我也行啊？你没谁也没交啊？最后我追问他什么时间开始做的PPT，老实人表示:“昨天晚上你说我没交PPT以后。”原来并不是老实人早早做完老实到不知道交，而是老实人根本就没做。\n一番令人无语凝噎的对话将我对老实人本来充沛的同情心消磨殆尽，我将谈话记录原原本本告知了F总和X博，心里也从一开始“还有变好的可能”转向了F总的开除方案，在微信上和老实人布置了他的新工作（不然老实人会像PPT事件一样说你没说过），并且警告他如果到5月没有改善，就会面临开除风险。老实人微信回了一个“好的”就陷入了死寂。 \n老实人的传统艺能“你没说”和“我不会”第二天一早，我就给老实人开始布置各种活计，由于跨部门交流本身就琐碎事情多，且昨天刚刚接到做不好就开除的通知，老实人头一次破天荒地拿出了他的记录本，认真用笔写下了要做的事情。\n然而慢节奏的行事风格早已养成，改起来哪是一日之功？老实人忙碌了一早上，才完成了其他人2小时内就能完成的任务，甚至因为觉得他太慢，我让小助理又分担了他的一部分工作。饶是这样，老实人依然出现了漏交材料的情况。老实人刚上交去不久，对接部门的A总就打电话过来，一一询问起我问题来。其中某个漏交的资料一开始没找到，后面找到了，我通知了老实人让他经B部门交给A部门，最后老实人却没交。我一问，老实人立马冤枉搬地喊起来“你没说……”然后又想起自己的微信记录板上钉钉，把后半句生生咽下去，立刻站起来去对接B部门了。\n下午，同样的事情又发生了一遍，老实人忙碌了两个小时，只交上来一份清单给我:一个5行，三列的excel。甚至在这15格内容里，依然还写错了一个数字。我问另一份清单在哪里，老实人依然稳定发挥了他的传统艺能“你没说！”我也依然一招制敌，拿出了聊天记录。然而老实人又开始了第二招“我不会，模板在哪里。”说实话，这两个文件在老实人躺赢在重要项目的时代里都经过他手，而此刻他的硬盘里就躺着他亲手写过的资料和模板。被我指出后，老实人一言不发地在他的电脑里找到了模板写了起来。\n到了晚上我去查看老实人的实验数据，发现他早上兢兢业业处理了1个小时的数据又出现了处理错误，接到电话的老实人急急忙忙赶过来，并且依然稳定发挥着不认账的传统，直到旁边的组员妹妹说“是有问题，我们都看见了”。老实人一边叹气重新处理，一边抱怨他今天一天“真是忙死了”，这忙死他的一天工作基本上也就是我半天的工作量，我只笑笑“现在你体会到我的工作了吧”。\n老实人眼神此时黯淡了起来，说起自己接到昨天的通知是多么害怕，此刻我该死的同情心又一次开始运转，安慰他好好努力完成任务，说不定领导就不生气了。\n","categories":["工作"],"tags":["职场日常，老实人，辞退"]},{"title":"辞退职场“老实人”（下）","url":"/2023/05/03/%E8%BE%9E%E9%80%80%E8%81%8C%E5%9C%BA%E2%80%9C%E8%80%81%E5%AE%9E%E4%BA%BA%E2%80%9D%EF%BC%88%E4%B8%8B%EF%BC%89/","content":"老实人的天降刀子是夜，F总和我们分享了一段他和A总的对话。原来A总觉得交接工作变成老实人负责很是诧异，问起来才得知F总要开掉老实人。结果得知此事的A总高兴地要请F总吃饭！原来老实人在前领导那里时，经常藉由前领导对其的偏爱推掉本该属于他自己的工作。一次A总希望老实人查查文献，协助写一下市场报告，最后老实人交上的报告却一塌糊涂不成样子。A总找到前领导，谁知却被前领导臭骂一顿，说他给的工作指令不明，根本不该柔弱无助的老实人承担。最后该报告也不了了之。\nX博听闻，表示之前和老实人打过交道的各路中高层，都不太看得上老实人，F总此时才感受到了前领导的护宝威力，知道当时被硬塞了一个怎样的人。而F总也从之前“如果不改就开除”的思想变成了坚决开除。思路也从帮助他改进变成了怎么收集证据证明他不胜任了。\n结果，第二天一早，还没等我制定PIP，我就发现钉钉系统上推送了一个通知。是老实人的劳动合同续签的提醒。细细一研究，发现老实人的合同竟然5月31号就到期了！而且在这里深耕多年的老实人，竟已经续签过两次合同，下次再签就是无固定期限的劳动合同了。F总当机立断拒绝了续签，表示老实人的工作态度还需要考察。而本来可能谨慎推进，收集证据的计划，也因为这个契机加速了起来，F总直接上报了大老板有意开除老实人，没想到这件事却被大老板树立成了正面典型，顺便又踩了一脚前领导，告诉大家上梁不正下梁歪，老实人刚去新部门三个月就被认为不合格，让大家引以为戒。\n公正的说，前领导确实是个好人，但不是一个好领导。在他的部门里，我们非常闲，甚至有位新员工没过试用期就主动离职，因为太闲了她怕待废。当时的我并没有选择像老实人一样躲在他背后拒绝工作，而是主动承担了很多任务，开发了好几个有挑战性的方法，但每个工作做完之后却都没有下文，不了了之。如果不是把我们拨给了F总，可能我也会在这样的温水环境里慢慢沉沦，最后变成一只被煮死的青蛙吧。\n“不上了”从得知老实人可能被开到棺材上的钉子一颗一颗钉死的过程中，睡眠质量极其优秀的我开始日日失眠。\n毕竟真要开除昔日一起共事的同事，还是家庭情况困难的同事，我根本下不了这个决心，特别是每次批评他时那一脸无辜的表情，被吓到般身体僵住和默不吭声的样子，都显得我像电视剧里职场霸凌的无良主管，而他则是那黑暗不堪的职场里唯一一朵盛开的小白花。只不过这位老哥的颜值属实无法带入想象，不然苦情电视剧的主角应有他的一席之地。但这也常常能给我致命一击，令我在同情和生气的两种感情中反复横跳，陷入失眠的状态。\n第二日一早，我顶着只睡了4个小时的状态上了班，却没发现老实人的身影，打开钉钉，发现老实人没打卡。虽然我们是不定时工作制，不用按时打卡，但老实人别的不说，从不迟到早退，极其遵守公司制度。由于在实验室和办公室都没发现老实人，我赶紧私聊老实人，叫他补上打卡记录，不然一天班白上。谁知却得到一句回复:“不上了。”\n我心下愕然，以为老实人已经得知自己要被开除的消息，破罐破摔，一时间脑子里已经转了800个弯，不知从何说起，最终却只说出这样一句话“那你把该退的群都退了吧”，心里五味杂陈，面上却强装镇定依旧做实验，结果过了一会老实人急匆匆跑来，“你说退群是啥意思啊？”我反问，“你不是说你不上班了吗？”“哎？我说的是补上了啊”我再一次拿出聊天记录给他看，他看了看，连忙哭笑不得地解释说他打错了，是补上了补上了。实验室的其他同事也开始调笑，说你怎么这么果断就开始打算接受他辞职了，不是应该先打电话问问吗？我假装跟着哈哈大笑，心里却更加苦涩，不久的将来，老实人真有一天要面对这件事情，届时他能接受吗？ \n对别部门唯唯诺诺，对本部门能拖就拖自从将对接沟通的事情交给老实人后，我将精力集中到内部实验管理上。实验也接连取得突破性进展，就是最近大家的问题比较多，我打算开展一次系统性的研发培训，算算时间，上午大家应该都有空，于是在群里问了大家。大家很快回复都有空，唯有老实人表示自己要对接一上午，下午才可以。我心知老实人下午还有个耗时很长的实验，自己的培训却至少要讲两个小时，若是下午讲老实人必定要加班，何况对接的工作我自己一直在做，知道大部分时间都在打字对话沟通，改文件和写文件上，是随时能够按暂停键的工作。\n想到老实人之前磨洋工的“珠玉在前”，有点生气，于是追问他有什么工作要对接一上午？回答果然没让我“失望”，是两件鸡毛蒜皮的小事，而且甚至还有一件明显是其他部门责任范围的事情，大概每件事情5分钟内就能做到。老实人反说“可能还有其他的事情，自己要给他们留够一上午进行充分的对接。”我属实无语，他宁愿为其他部门“可能的事情”预留一上午，也不能为本部门的培训抽出两小时。再次问他最早早上几点能结束，得到的答案是十一点。最后我终于不客气地骂他5分钟就能搞定的事情要磨两个小时，并且直接下了最后通牒，十点开始培训。\n十点，老实人按时参加了培训，期间也没有看到他被紧急电话叫出去或者回复工作信息，一切风平浪静。看来他预想的对接事件并没有发生。我趁机也宣布了下午让助理组员和老实人跟一遍他的实验流程学习一下（是的，我已经开始布局交接问题了），老实人也一一应下。\n下午到了，助理组员一直等待着老实人过来，然而1个半小时过去了，老实人依然没来。“电话打了，他说他在忙着写文件。”眼看再不开始实验今天下午老实人必定要加班，还要连累助理和他一起加班，于是我一个电话打过去，告诉他文件晚点再写，先做实验再说。他则坚持把“其他部门催”的写完再过来。\n到了下班时间，对接部门的同事来了实验室找老实人，又开始了新的一轮拉扯，说他们领导提出过程太复杂，要删掉几个检测指标。对于这样敏感的无理要求，老实人居然一一应下，我眼见不妙，立刻出声制止，力陈指标的重要性，最终与对方商议后达成新共识，据此再度修改文件。只是老实人写文件的努力付诸东流，而且实验也连累助理加班到了晚上8点。\n被00后牵着鼻子走的80后假期前倒数第二天，老实人主动将他这一周的交接文件打包发给了我审核。由于当时早已下班，我答应他明天有空的时候复核。\n第二天下午，老实人问我要一份文件，据他称是“A部门要，上报集团的”。我手头并没有这份文件，而且如果要这份文件应该需要F总与合作方沟通才能取得，便让他直接联系F总。谁知过了一会F总便在群里怒气冲冲的问为什么老实人一个电话打给他要这份文件。我也诧异，不是A部门要的吗？于是赶紧联系A部门的A总，请问他对这份文件具体有什么需求。然而A总却回复:“谁让你交这份文件的？”\n在一头雾水的我打了一圈电话后，终于弄清了事情的原委:原来A部门的00后员工小L接到集团要求补充两个问题的说明，小L不知出于何意却向B部门同为00后的小G说自己要这份不好取得的文件（可能觉得文件里会有答案吧），小G表示自己没有，直接向老实人当起了伸手党。而老实人问也不问为什么，到处找起了文件。整个过程中，F总，我，小G的大小领导以及小L的大小领导通通不知情，完全是因为小L的突发奇想导演出来的一场大戏。\n弄清原委的F总阴阳了一句“现在的小朋友真有主见。”我则无奈的纠正，是“老朋友”和“小朋友们”。在整个事件中，80后的老实人被两个00后牵着鼻子走，虽说主要责任可不是他的，但是这种处理方式也着实不像一个35+的员工应该有的水平，但凡他多问一句小L，这件事情可能就不会发生，当然，我也有责任，听到了老实人的“A部门要，上报集团”就以为是A总要，未曾细究这个到底是A总还是A部门的某人。\n可谁知一波未平，一波又起，因此而牵出的第二件事才真正让我对老实人发火的原因。\n该谨慎时大胆，该大胆时谨慎好不容易解释清楚了这件事情，没过多久F总接着又给我发了一份文件过来，问我为什么这里和我之前发给他的不一样，而这个重要信息又被老实人填错了。我一看，这不是我之前发的一份，而是另一份文件，而这份文件是昨天老实人打包发给我的那堆文件里的一部分，我今天还没顾得上审核。F总冷冷的道:“这份文件可是我从A总手里拿到的，他看到有问题赶紧告诉了我。”\n我还没有审核的文件，为什么直接出现在了其他部门手里？他又有多少文件已经单方面和别人“敲定”，甚至已经盖章签字打印成型了？联想到A、B部门两位00后的行事风格，我心下一凉，赶紧叫住了刚刚回来的老实人。\n“你文件都已经交给他们了？”\n老实人一副理所当然的语气:“对呀，都交给他们了。”\n本来下定决心在最后的日子里不对老实人发火的我（上篇的事件我也没发火，只是明白原委后说责任主要不在你，劝老实人以后多问两句）终于没有忍住提高了音量:“我还没有复核你为什么要交给其他部门！”\n老实人仍然回以理所当然的语气:“他们催着我要啊，我就都给了。我们都敲定好了。”\n我忍不住怒吼:“他们催着你要你就给他们了？那你还让我复核干什么呢？你们都敲定了还给我复核什么呢？！”\n撂下一脸懵逼的老实人（他甚至还不知道自己做错了什么），我赶紧向F总汇报了这件事，并提出要我将交接工作收回，坚决再不能让老实人负责此事，而且这种私下敲定，隐瞒不报的行事风格绝不能留，应该坚决开除。F总大感无语，没想到平日做事畏首畏尾的老实人居然自己做了这么大的主，称老实人:“该大胆的时候谨慎，该谨慎的时候大胆。到底前领导是多么喜欢他，才给公司留了这么个神奇宝贝？”\n梦幻泡泡的破碎——与老实人的谈话也许F总从一开始将老实人调来负责他最不擅长的工作，就是为了制造更多的冲突，让我看清老实人扶不起的现实，并且引导我自己下定决心开除罢了。但是不管怎么说，我也感谢F总让我看清了这一切。我将老实人叫来，正式通知了他合同到期后不予续签的决定，让他下个月也不用做太多事情，自己准备好好找工作吧。老实人听后出乎意料的平静，表示自己早有预感。但仍然追问自己不续签的原因，是因为自己昨天要那份文件吗？是因为自己PPT没讲好吗？是因为前领导部门被拆分，已经有一个分去其他部门的员工被开除了所以自己也要被干掉吗？“是，但是它们都不是主要原因。”他絮絮叨叨将这几天他觉得有错的事情一一翻出，而我则帮他又分析了一遍。“那，只因为这个月没有做好，我就要被开除吗？”\n我深吸了一口气，问他一个问题:“你觉得你的能力，在我手下的员工手里，能排到第几？”我本以为老实人对自己的能力到底是应该有客观认知的，出乎我意料地，他竟然觉得他和我手下最优秀的组员妹妹（就是会上给了他方案的妹妹）能力上五五开！我笑道:“开会的时候你连人家告诉你的方案都听不懂，更别提自己想的到，而且这个妹妹只要简短的和她描述一下大致思路，她就能自发设计方案并且完成，你觉得你和她差不多？”\n老实人瞪大了眼睛:“方案是她自己写的？没有模板？”在得到了肯定的回答之后，老实人一时语塞，又很快环视了一圈实验室新添置的仪器，嘴里嘟囔着:“这些仪器我不会用，要是有人教我用我也能……”\n“你说这些我刚买的小仪器吗？这些仪器我买之前我也不会用啊，我们也都是对着说明书研究，操作指南还是大专生小助理写的呢，她可是专业不对口而且刚来实验室9个月而已。在我眼里，你的实验能力和小助理差不多，也就是你是研究生，文字和计算功底稍微比她强点。”老实人第一次发现我眼中的他竟然是这般评价，想要找出些证据反驳我，却发现似乎没有什么能证明他光辉历史的东西。我则就这个问题进一步攻击。\n“你和X博一直不睦，对吧？你知道她为什么这么针对你吗？”\n“我不知道……她确实有点……但……”\n“因为，她忍受不了蠢人。”\n而这个事实似乎也并不能让他相信，于是我使出了最后的杀手锏:“你知道当初把我和X博分给F总，但是没有分你，你知道前领导怎么说你的吗？”\n“他说，老实人能力也不行，实验也不太行，还是就在我这里吧。”\n","categories":["工作"],"tags":["职场日常，老实人，辞退"]}]